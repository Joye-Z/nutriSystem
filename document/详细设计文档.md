# 健康食谱管理与膳食规划系统
## 详细设计文档

## 1. 文档概述

### 1.1 文档目的
本文档详细描述健康食谱管理与膳食规划系统的技术实现细节，包括类结构设计、方法实现、算法流程、数据库设计、API接口规范等内容，为开发团队提供具体的编码指导。

### 1.2 术语定义
| 术语 | 解释 |
|------|------|
| DTO | 数据传输对象（Data Transfer Object），用于应用层之间传输数据的对象 |
| VO | 值对象（Value Object），表示只读的数据集合 |
| POJO | 普通Java对象（Plain Old Java Object），不依赖特定框架的Java对象 |
| AOP | 面向切面编程（Aspect-Oriented Programming），将横切关注点与业务逻辑分离 |
| RBAC | 基于角色的访问控制（Role-Based Access Control），通过角色权限管理系统访问 |
| JWT | JSON Web Token，一种用于安全传输信息的开放标准 |
| BMI | 体重指数，计算公式：体重(kg) / 身高(m)² |
| BMR | 基础代谢率，维持生命所需的最低能量消耗 |
| TDEE | 总能量消耗，每日总能量消耗 |

## 2. 需求分析

### 2.1 功能需求

| 功能模块 | 功能点 | 详细描述 |
|---------|--------|----------|
| 用户管理 | 用户注册 | 用户通过手机号/邮箱注册账号，设置密码和基本信息 |
| 用户管理 | 用户登录 | 支持用户名/手机号登录，提供验证码登录方式 |
| 用户管理 | 个人信息管理 | 用户可查看和修改个人信息、健康数据（身高、体重、年龄等） |
| 用户管理 | 密码修改 | 用户可修改登录密码，支持找回密码功能 |
| 食谱管理 | 食谱浏览 | 用户可浏览所有食谱，支持分页、分类筛选 |
| 食谱管理 | 食谱搜索 | 支持按名称、食材、口味等条件搜索食谱 |
| 食谱管理 | 食谱详情 | 查看食谱的详细信息，包括配料、步骤、营养成分等 |
| 食谱管理 | 收藏/点赞 | 用户可收藏喜欢的食谱，对食谱进行点赞 |
| 膳食计划 | 计划创建 | 根据用户健康数据和偏好，自动生成个性化膳食计划 |
| 膳食计划 | 计划管理 | 用户可查看、修改、删除已创建的膳食计划 |
| 膳食计划 | 计划执行 | 记录膳食计划的执行情况，提供完成进度追踪 |
| 膳食计划 | 食材清单 | 根据膳食计划自动生成所需食材清单，便于采购 |
| 营养分析 | 营养计算 | 计算食谱和膳食计划的营养成分，包括热量、蛋白质、脂肪等 |
| 营养分析 | 营养建议 | 根据用户健康数据，提供个性化的营养摄入建议 |
| 营养分析 | 统计报表 | 生成营养摄入统计报表，展示每日/每周营养摄入情况 |
| 系统管理 | 角色管理 | 管理系统角色，分配不同的操作权限 |
| 系统管理 | 日志管理 | 记录系统操作日志，包括登录、数据修改等操作 |
| 系统管理 | 数据备份 | 定期备份系统数据，确保数据安全 |

### 2.2 非功能需求

| 需求类别 | 详细描述 |
|---------|----------|
| 性能需求 | 系统响应时间不超过2秒，支持并发用户数1000人以上 |
| 可用性需求 | 系统可用性达到99.9%，计划内维护时间不超过每月4小时 |
| 安全性需求 | 采用自定义认证机制，密码加密存储，数据传输采用HTTPS |
| 可扩展性需求 | 系统采用模块化设计，支持功能模块的独立开发和部署 |
| 兼容性需求 | 支持主流浏览器（Chrome、Firefox、Safari、Edge），移动端响应式设计 |
| 可维护性需求 | 代码注释率达到80%以上，采用统一的编码规范 |
| 国际化需求 | 支持多语言切换，初期支持中文和英文 |

### 2.3 数据需求

| 数据类别 | 数据内容 | 存储方式 |
|---------|---------|----------|
| 用户数据 | 用户基本信息、健康数据、账号安全信息 | 关系型数据库 |
| 食谱数据 | 食谱基本信息、配料、步骤、营养成分、分类信息 | 关系型数据库 + 阿里云OSS存储（图片） |
| 膳食计划数据 | 计划基本信息、每日餐次、关联食谱、执行记录 | 关系型数据库 |
| 营养数据 | 营养成分数据、用户营养需求、分析结果 | 关系型数据库 |
| 系统数据 | 角色权限、操作日志、系统配置 | 关系型数据库 |
| 缓存数据 | 热点食谱、用户会话、配置信息 | 自定义内存缓存 |

## 3. 类结构设计

### 2.1 实体层设计

#### 2.1.1 Account类
```java
/**
 * 用户基类
 * 所有角色用户的父类，包含基础用户信息
 */
public class Account {
    private Integer id;            // 用户ID
    private String username;       // 用户名
    private String name;           // 姓名
    private String password;       // 密码
    private String role;           // 角色标识
    private String newPassword;    // 新密码（用于密码修改）
    private String avatar;         // 头像
    private String phone;          // 手机号
    private String email;          // 邮箱
    private Integer loginFailCount; // 登录失败次数
    private LocalDateTime lastLoginTime; // 最后登录时间

    // getter和setter方法
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getNewPassword() {
        return newPassword;
    }

    public void setNewPassword(String newPassword) {
        this.newPassword = newPassword;
    }

    public String getAvatar() {
        return avatar;
    }

    public void setAvatar(String avatar) {
        this.avatar = avatar;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getLoginFailCount() {
        return loginFailCount;
    }

    public void setLoginFailCount(Integer loginFailCount) {
        this.loginFailCount = loginFailCount;
    }

    public LocalDateTime getLastLoginTime() {
        return lastLoginTime;
    }

    public void setLastLoginTime(LocalDateTime lastLoginTime) {
        this.lastLoginTime = lastLoginTime;
    }
}
```

#### 2.1.2 User类
```java
/**
 * 普通用户类
 * 继承自Account，包含健康相关信息
 */
public class User extends Account {
    private Double height;         // 身高(cm)
    private Double weight;         // 体重(kg)
    private Integer age;           // 年龄
    private String gender;         // 性别
    private String activityLevel;  // 活动水平
    private String goal;           // 健康目标
    private Double bmi;            // 体重指数
    private String physicalStatus; // 身体状态描述
    private LocalDateTime healthDataUpdateTime; // 健康数据更新时间

    // getter和setter方法
    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public Double getWeight() {
        return weight;
    }

    public void setWeight(Double weight) {
        this.weight = weight;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getActivityLevel() {
        return activityLevel;
    }

    public void setActivityLevel(String activityLevel) {
        this.activityLevel = activityLevel;
    }

    public String getGoal() {
        return goal;
    }

    public void setGoal(String goal) {
        this.goal = goal;
    }

    public Double getBmi() {
        return bmi;
    }

    public void setBmi(Double bmi) {
        this.bmi = bmi;
    }

    public String getPhysicalStatus() {
        return physicalStatus;
    }

    public void setPhysicalStatus(String physicalStatus) {
        this.physicalStatus = physicalStatus;
    }

    public LocalDateTime getHealthDataUpdateTime() {
        return healthDataUpdateTime;
    }

    public void setHealthDataUpdateTime(LocalDateTime healthDataUpdateTime) {
        this.healthDataUpdateTime = healthDataUpdateTime;
    }

    /**
     * 计算BMI值
     * @return BMI值
     */
    public Double calculateBMI() {
        if (height == null || weight == null || height <= 0 || weight <= 0) {
            return null;
        }
        return weight / Math.pow(height / 100, 2);
    }

    /**
     * 获取BMI状态描述
     * @return BMI状态描述
     */
    public String getBMIStatus() {
        Double bmiValue = calculateBMI();
        if (bmiValue == null) {
            return "数据不足";
        }
        if (bmiValue < 18.5) {
            return "偏瘦";
        } else if (bmiValue < 24) {
            return "正常";
        } else if (bmiValue < 28) {
            return "超重";
        } else {
            return "肥胖";
        }
    }
}
```

#### 2.1.3 Recipe类
```java
/**
 * 食谱类
 * 包含食谱的详细信息
 */
public class Recipe {
    private Integer id;            // 食谱ID
    private String name;           // 食谱名称
    private String description;    // 食谱描述
    private String ingredients;    // 食材清单(JSON格式)
    private String steps;          // 烹饪步骤(JSON格式)
    private Integer cookingTime;   // 烹饪时间(分钟)
    private Integer calories;      // 热量(卡路里)
    private BigDecimal protein;    // 蛋白质(g)
    private BigDecimal carbohydrate; // 碳水化合物(g)
    private BigDecimal fat;        // 脂肪(g)
    private String category;       // 分类(早餐、午餐等)
    private String difficulty;     // 难度(简单、中等、困难)
    private String image;          // 食谱图片URL
    private Integer viewCount;     // 浏览次数
    private Integer favoriteCount; // 收藏次数
    private Integer commentCount;  // 评论次数
    private LocalDateTime createTime; // 创建时间
    private LocalDateTime updateTime; // 更新时间

    // getter和setter方法
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getIngredients() {
        return ingredients;
    }

    public void setIngredients(String ingredients) {
        this.ingredients = ingredients;
    }

    public String getSteps() {
        return steps;
    }

    public void setSteps(String steps) {
        this.steps = steps;
    }

    public Integer getCookingTime() {
        return cookingTime;
    }

    public void setCookingTime(Integer cookingTime) {
        this.cookingTime = cookingTime;
    }

    public Integer getCalories() {
        return calories;
    }

    public void setCalories(Integer calories) {
        this.calories = calories;
    }

    public BigDecimal getProtein() {
        return protein;
    }

    public void setProtein(BigDecimal protein) {
        this.protein = protein;
    }

    public BigDecimal getCarbohydrate() {
        return carbohydrate;
    }

    public void setCarbohydrate(BigDecimal carbohydrate) {
        this.carbohydrate = carbohydrate;
    }

    public BigDecimal getFat() {
        return fat;
    }

    public void setFat(BigDecimal fat) {
        this.fat = fat;
    }

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public String getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(String difficulty) {
        this.difficulty = difficulty;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public Integer getViewCount() {
        return viewCount;
    }

    public void setViewCount(Integer viewCount) {
        this.viewCount = viewCount;
    }

    public Integer getFavoriteCount() {
        return favoriteCount;
    }

    public void setFavoriteCount(Integer favoriteCount) {
        this.favoriteCount = favoriteCount;
    }

    public Integer getCommentCount() {
        return commentCount;
    }

    public void setCommentCount(Integer commentCount) {
        this.commentCount = commentCount;
    }

    public LocalDateTime getCreateTime() {
        return createTime;
    }

    public void setCreateTime(LocalDateTime createTime) {
        this.createTime = createTime;
    }

    public LocalDateTime getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(LocalDateTime updateTime) {
        this.updateTime = updateTime;
    }

    /**
     * 获取食材列表对象
     * @return 食材列表
     */
    public List<Ingredient> getIngredientsList() {
        if (ingredients == null || ingredients.isEmpty()) {
            return new ArrayList<>();
        }
        try {
            return new ObjectMapper().readValue(ingredients, new TypeReference<List<Ingredient>>() {});
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }

    /**
     * 获取烹饪步骤列表
     * @return 烹饪步骤列表
     */
    public List<String> getStepsList() {
        if (steps == null || steps.isEmpty()) {
            return new ArrayList<>();
        }
        try {
            return new ObjectMapper().readValue(steps, new TypeReference<List<String>>() {});
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }

    /**
     * 食材类
     */
    public static class Ingredient {
        private String name;        // 食材名称
        private String amount;      // 用量
        private String unit;        // 单位
        // getter和setter方法
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getAmount() { return amount; }
        public void setAmount(String amount) { this.amount = amount; }
        public String getUnit() { return unit; }
        public void setUnit(String unit) { this.unit = unit; }
    }
}
```

#### 2.1.4 MealPlan类
```java
/**
 * 膳食计划类
 * 记录用户的餐饮安排
 */
public class MealPlan {
    private Integer id;            // 膳食计划ID
    private Integer userId;        // 用户ID
    private String planName;       // 计划名称
    private LocalDate planDate;    // 计划日期
    private String mealType;       // 餐次类型(早餐、午餐、晚餐、加餐)
    private Integer recipeId;      // 关联的食谱ID
    private String customMeal;     // 自定义餐食内容
    private Integer calories;      // 热量(卡路里)
    private String notes;          // 备注
    private Boolean isCompleted;   // 是否完成
    private String completionTime; // 完成时间
    private LocalDateTime createTime; // 创建时间
    private LocalDateTime updateTime; // 更新时间
    private Recipe recipe;         // 关联的食谱信息

    // getter和setter方法
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    public String getPlanName() {
        return planName;
    }

    public void setPlanName(String planName) {
        this.planName = planName;
    }

    public LocalDate getPlanDate() {
        return planDate;
    }

    public void setPlanDate(LocalDate planDate) {
        this.planDate = planDate;
    }

    public String getMealType() {
        return mealType;
    }

    public void setMealType(String mealType) {
        this.mealType = mealType;
    }

    public Integer getRecipeId() {
        return recipeId;
    }

    public void setRecipeId(Integer recipeId) {
        this.recipeId = recipeId;
    }

    public String getCustomMeal() {
        return customMeal;
    }

    public void setCustomMeal(String customMeal) {
        this.customMeal = customMeal;
    }

    public Integer getCalories() {
        return calories;
    }

    public void setCalories(Integer calories) {
        this.calories = calories;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public Boolean getIsCompleted() {
        return isCompleted;
    }

    public void setIsCompleted(Boolean isCompleted) {
        this.isCompleted = isCompleted;
    }

    public String getCompletionTime() {
        return completionTime;
    }

    public void setCompletionTime(String completionTime) {
        this.completionTime = completionTime;
    }

    public LocalDateTime getCreateTime() {
        return createTime;
    }

    public void setCreateTime(LocalDateTime createTime) {
        this.createTime = createTime;
    }

    public LocalDateTime getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(LocalDateTime updateTime) {
        this.updateTime = updateTime;
    }

    public Recipe getRecipe() {
        return recipe;
    }

    public void setRecipe(Recipe recipe) {
        this.recipe = recipe;
    }

    /**
     * 获取膳食计划的显示名称
     * @return 显示名称
     */
    public String getDisplayName() {
        if (recipe != null) {
            return recipe.getName();
        } else if (customMeal != null && !customMeal.isEmpty()) {
            return customMeal;
        } else {
            return "未命名膳食";
        }
    }

    /**
     * 标记完成状态
     * @param completed 是否完成
     */
    public void markAsCompleted(Boolean completed) {
        this.isCompleted = completed;
        if (completed) {
            this.completionTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));
        } else {
            this.completionTime = null;
        }
    }
}
```

### 2.2 数据传输对象（DTO）设计

#### 2.2.1 LoginRequest
```java
/**
 * 登录请求DTO
 */
public class LoginRequest {
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    
    private String captcha;        // 验证码
    private String captchaKey;     // 验证码key

    // getter和setter方法
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getCaptcha() {
        return captcha;
    }

    public void setCaptcha(String captcha) {
        this.captcha = captcha;
    }

    public String getCaptchaKey() {
        return captchaKey;
    }

    public void setCaptchaKey(String captchaKey) {
        this.captchaKey = captchaKey;
    }
}
```

#### 2.2.2 LoginResponse
```java
/**
 * 登录响应DTO
 */
public class LoginResponse {
    private Account userInfo;         // 用户信息

    // getter和setter方法
    public Account getUserInfo() {
        return userInfo;
    }

    public void setUserInfo(Account userInfo) {
        this.userInfo = userInfo;
    }
}
```

#### 2.2.3 RegisterRequest
```java
/**
 * 注册请求DTO
 */
public class RegisterRequest {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 20, message = "用户名长度必须在4-20个字符之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20个字符之间")
    private String password;
    
    @NotBlank(message = "姓名不能为空")
    private String name;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Pattern(regexp = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$", message = "邮箱格式不正确")
    private String email;
    
    private String verificationCode; // 验证码

    // getter和setter方法
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getVerificationCode() {
        return verificationCode;
    }

    public void setVerificationCode(String verificationCode) {
        this.verificationCode = verificationCode;
    }
}
```

#### 2.2.4 NutritionPlanRequest
```java
/**
 * 营养计划请求DTO
 */
public class NutritionPlanRequest {
    private Double height;         // 身高(cm)
    private Double weight;         // 体重(kg)
    private Integer age;           // 年龄
    private String gender;         // 性别
    private String activityLevel;  // 活动水平
    private String goal;           // 健康目标
    
    // getter和setter方法
    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public Double getWeight() {
        return weight;
    }

    public void setWeight(Double weight) {
        this.weight = weight;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getActivityLevel() {
        return activityLevel;
    }

    public void setActivityLevel(String activityLevel) {
        this.activityLevel = activityLevel;
    }

    public String getGoal() {
        return goal;
    }

    public void setGoal(String goal) {
        this.goal = goal;
    }
}
```

#### 2.2.5 NutritionPlanResponse
```java
/**
 * 营养计划响应DTO
 */
public class NutritionPlanResponse {
    private Double bmr;              // 基础代谢率
    private Double tdee;             // 总能量消耗
    private Double recommendedCalories; // 推荐卡路里摄入量
    private Map<String, Double> nutrientRequirements; // 营养素需求
    private String nutritionAdvice;  // 营养建议
    private Double bmi;              // BMI值
    private String bmiStatus;        // BMI状态
    
    // getter和setter方法
    public Double getBmr() {
        return bmr;
    }

    public void setBmr(Double bmr) {
        this.bmr = bmr;
    }

    public Double getTdee() {
        return tdee;
    }

    public void setTdee(Double tdee) {
        this.tdee = tdee;
    }

    public Double getRecommendedCalories() {
        return recommendedCalories;
    }

    public void setRecommendedCalories(Double recommendedCalories) {
        this.recommendedCalories = recommendedCalories;
    }

    public Map<String, Double> getNutrientRequirements() {
        return nutrientRequirements;
    }

    public void setNutrientRequirements(Map<String, Double> nutrientRequirements) {
        this.nutrientRequirements = nutrientRequirements;
    }

    public String getNutritionAdvice() {
        return nutritionAdvice;
    }

    public void setNutritionAdvice(String nutritionAdvice) {
        this.nutritionAdvice = nutritionAdvice;
    }

    public Double getBmi() {
        return bmi;
    }

    public void setBmi(Double bmi) {
        this.bmi = bmi;
    }

    public String getBmiStatus() {
        return bmiStatus;
    }

    public void setBmiStatus(String bmiStatus) {
        this.bmiStatus = bmiStatus;
    }
}
```

### 2.3 服务层（Service）设计

#### 2.3.1 UserService接口及实现
```java
/**
 * 用户服务接口
 */
public interface UserService {
    /**
     * 添加用户
     * @param user 用户对象
     * @return 是否成功
     */
    boolean add(User user);
    
    /**
     * 删除用户
     * @param id 用户ID
     * @return 是否成功
     */
    boolean deleteById(Integer id);
    
    /**
     * 更新用户信息
     * @param user 用户对象
     * @return 是否成功
     */
    boolean updateById(User user);
    
    /**
     * 根据ID查询用户
     * @param id 用户ID
     * @return 用户对象
     */
    User selectById(Integer id);
    
    /**
     * 根据用户名查询用户
     * @param username 用户名
     * @return 用户对象
     */
    User selectByUsername(String username);
    
    /**
     * 分页查询用户列表
     * @param user 查询条件
     * @param pageNum 页码
     * @param pageSize 每页数量
     * @return 分页结果
     */
    PageInfo<User> selectPage(User user, Integer pageNum, Integer pageSize);
    
    /**
     * 验证用户名是否存在
     * @param username 用户名
     * @return 是否存在
     */
    boolean existsByUsername(String username);
    
    /**
     * 更新用户健康数据
     * @param userId 用户ID
     * @param healthData 健康数据
     * @return 是否成功
     */
    boolean updateHealthData(Integer userId, Map<String, Object> healthData);
    
    /**
     * 重置密码
     * @param userId 用户ID
     * @param oldPassword 旧密码
     * @param newPassword 新密码
     * @return 是否成功
     */
    boolean resetPassword(Integer userId, String oldPassword, String newPassword);
    
    /**
     * 更新用户登录信息
     * @param userId 用户ID
     * @param loginSuccess 是否登录成功
     */
    void updateLoginInfo(Integer userId, boolean loginSuccess);
}

/**
 * 用户服务实现类
 */
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Override
    public boolean add(User user) {
        // 加密密码
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        user.setRole("user"); // 默认角色
        user.setLoginFailCount(0);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        return userMapper.insert(user) > 0;
    }
    
    @Override
    public boolean deleteById(Integer id) {
        return userMapper.deleteById(id) > 0;
    }
    
    @Override
    public boolean updateById(User user) {
        user.setUpdateTime(LocalDateTime.now());
        // 如果修改了密码，进行加密
        if (user.getNewPassword() != null && !user.getNewPassword().isEmpty()) {
            user.setPassword(passwordEncoder.encode(user.getNewPassword()));
        }
        return userMapper.updateById(user) > 0;
    }
    
    @Override
    public User selectById(Integer id) {
        return userMapper.selectById(id);
    }
    
    @Override
    public User selectByUsername(String username) {
        return userMapper.selectByUsername(username);
    }
    
    @Override
    public PageInfo<User> selectPage(User user, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<User> list = userMapper.selectList(user);
        return new PageInfo<>(list);
    }
    
    @Override
    public boolean existsByUsername(String username) {
        return userMapper.countByUsername(username) > 0;
    }
    
    @Override
    public boolean updateHealthData(Integer userId, Map<String, Object> healthData) {
        User user = userMapper.selectById(userId);
        if (user == null) {
            return false;
        }
        
        // 设置健康数据
        if (healthData.containsKey("height")) {
            user.setHeight(Double.valueOf(healthData.get("height").toString()));
        }
        if (healthData.containsKey("weight")) {
            user.setWeight(Double.valueOf(healthData.get("weight").toString()));
        }
        if (healthData.containsKey("age")) {
            user.setAge(Integer.valueOf(healthData.get("age").toString()));
        }
        if (healthData.containsKey("gender")) {
            user.setGender(healthData.get("gender").toString());
        }
        if (healthData.containsKey("activityLevel")) {
            user.setActivityLevel(healthData.get("activityLevel").toString());
        }
        if (healthData.containsKey("goal")) {
            user.setGoal(healthData.get("goal").toString());
        }
        
        // 计算BMI
        user.setBmi(user.calculateBMI());
        user.setPhysicalStatus(user.getBMIStatus());
        user.setHealthDataUpdateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        
        return userMapper.updateById(user) > 0;
    }
    
    @Override
    public boolean resetPassword(Integer userId, String oldPassword, String newPassword) {
        User user = userMapper.selectById(userId);
        if (user == null) {
            return false;
        }
        
        // 验证旧密码
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            return false;
        }
        
        // 设置新密码
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setUpdateTime(LocalDateTime.now());
        return userMapper.updateById(user) > 0;
    }
    
    @Override
    public void updateLoginInfo(Integer userId, boolean loginSuccess) {
        User user = userMapper.selectById(userId);
        if (user == null) {
            return;
        }
        
        user.setLastLoginTime(LocalDateTime.now());
        if (loginSuccess) {
            user.setLoginFailCount(0); // 登录成功，重置失败次数
        } else {
            user.setLoginFailCount(user.getLoginFailCount() + 1); // 登录失败，增加失败次数
        }
        user.setUpdateTime(LocalDateTime.now());
        userMapper.updateById(user);
    }
}
```

#### 2.3.2 RecipeService接口及实现
```java
/**
 * 食谱服务接口
 */
public interface RecipeService {
    /**
     * 添加食谱
     * @param recipe 食谱对象
     * @return 是否成功
     */
    boolean add(Recipe recipe);
    
    /**
     * 删除食谱
     * @param id 食谱ID
     * @return 是否成功
     */
    boolean deleteById(Integer id);
    
    /**
     * 更新食谱
     * @param recipe 食谱对象
     * @return 是否成功
     */
    boolean updateById(Recipe recipe);
    
    /**
     * 根据ID查询食谱
     * @param id 食谱ID
     * @return 食谱对象
     */
    Recipe selectById(Integer id);
    
    /**
     * 根据分类查询食谱
     * @param category 分类
     * @return 食谱列表
     */
    List<Recipe> selectByCategory(String category);
    
    /**
     * 分页查询食谱列表
     * @param recipe 查询条件
     * @param pageNum 页码
     * @param pageSize 每页数量
     * @return 分页结果
     */
    PageInfo<Recipe> selectPage(Recipe recipe, Integer pageNum, Integer pageSize);
    
    /**
     * 搜索食谱
     * @param keyword 关键词
     * @param pageNum 页码
     * @param pageSize 每页数量
     * @return 分页结果
     */
    PageInfo<Recipe> search(String keyword, Integer pageNum, Integer pageSize);
    
    /**
     * 增加浏览次数
     * @param recipeId 食谱ID
     */
    void incrementViewCount(Integer recipeId);
    
    /**
     * 获取热门食谱
     * @param limit 数量限制
     * @return 食谱列表
     */
    List<Recipe> getPopularRecipes(Integer limit);
    
    /**
     * 根据营养需求推荐食谱
     * @param calorieRange 卡路里范围
     * @param category 分类（可选）
     * @param limit 数量限制
     * @return 食谱列表
     */
    List<Recipe> recommendByNutrition(Map<String, Integer> calorieRange, String category, Integer limit);
}

/**
 * 食谱服务实现类
 */
@Service
public class RecipeServiceImpl implements RecipeService {
    @Autowired
    private RecipeMapper recipeMapper;
    
    @Override
    public boolean add(Recipe recipe) {
        recipe.setViewCount(0);
        recipe.setFavoriteCount(0);
        recipe.setCommentCount(0);
        recipe.setCreateTime(LocalDateTime.now());
        recipe.setUpdateTime(LocalDateTime.now());
        return recipeMapper.insert(recipe) > 0;
    }
    
    @Override
    public boolean deleteById(Integer id) {
        return recipeMapper.deleteById(id) > 0;
    }
    
    @Override
    public boolean updateById(Recipe recipe) {
        recipe.setUpdateTime(LocalDateTime.now());
        return recipeMapper.updateById(recipe) > 0;
    }
    
    @Override
    public Recipe selectById(Integer id) {
        Recipe recipe = recipeMapper.selectById(id);
        if (recipe != null) {
            // 异步增加浏览次数
            CompletableFuture.runAsync(() -> incrementViewCount(id));
        }
        return recipe;
    }
    
    @Override
    public List<Recipe> selectByCategory(String category) {
        return recipeMapper.selectByCategory(category);
    }
    
    @Override
    public PageInfo<Recipe> selectPage(Recipe recipe, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<Recipe> list = recipeMapper.selectList(recipe);
        return new PageInfo<>(list);
    }
    
    @Override
    public PageInfo<Recipe> search(String keyword, Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<Recipe> list = recipeMapper.search(keyword);
        return new PageInfo<>(list);
    }
    
    @Override
    public void incrementViewCount(Integer recipeId) {
        recipeMapper.incrementViewCount(recipeId);
    }
    
    @Override
    public List<Recipe> getPopularRecipes(Integer limit) {
        return recipeMapper.selectPopular(limit);
    }
    
    @Override
    public List<Recipe> recommendByNutrition(Map<String, Integer> calorieRange, String category, Integer limit) {
        return recipeMapper.selectByNutritionRange(calorieRange.get("min"), calorieRange.get("max"), category, limit);
    }
}
```

#### 2.3.3 MealPlanService接口及实现
```java
/**
 * 膳食计划服务接口
 */
public interface MealPlanService {
    /**
     * 添加膳食计划
     * @param mealPlan 膳食计划对象
     * @return 是否成功
     */
    boolean add(MealPlan mealPlan);
    
    /**
     * 删除膳食计划
     * @param id 膳食计划ID
     * @return 是否成功
     */
    boolean deleteById(Integer id);
    
    /**
     * 更新膳食计划
     * @param mealPlan 膳食计划对象
     * @return 是否成功
     */
    boolean updateById(MealPlan mealPlan);
    
    /**
     * 根据ID查询膳食计划
     * @param id 膳食计划ID
     * @return 膳食计划对象
     */
    MealPlan selectById(Integer id);
    
    /**
     * 根据用户ID查询膳食计划
     * @param userId 用户ID
     * @return 膳食计划列表
     */
    List<MealPlan> selectByUserId(Integer userId);
    
    /**
     * 查询日期范围内的膳食计划
     * @param userId 用户ID
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @return 膳食计划列表
     */
    List<MealPlan> selectByDateRange(Integer userId, LocalDate startDate, LocalDate endDate);
    
    /**
     * 检查某日期是否有膳食计划
     * @param userId 用户ID
     * @param planDate 计划日期
     * @param mealType 餐次类型（可选）
     * @return 是否存在
     */
    boolean hasPlan(Integer userId, LocalDate planDate, String mealType);
    
    /**
     * 批量添加膳食计划
     * @param mealPlans 膳食计划列表
     * @return 是否成功
     */
    boolean batchAdd(List<MealPlan> mealPlans);
    
    /**
     * 标记膳食计划完成状态
     * @param mealPlanId 膳食计划ID
     * @param completed 是否完成
     * @return 是否成功
     */
    boolean markAsCompleted(Integer mealPlanId, Boolean completed);
    
    /**
     * 获取用户每日膳食计划统计
     * @param userId 用户ID
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @return 统计数据
     */
    Map<String, Object> getDailyStatistics(Integer userId, LocalDate startDate, LocalDate endDate);
}

/**
 * 膳食计划服务实现类
 */
@Service
public class MealPlanServiceImpl implements MealPlanService {
    @Autowired
    private MealPlanMapper mealPlanMapper;
    
    @Autowired
    private RecipeService recipeService;
    
    @Override
    public boolean add(MealPlan mealPlan) {
        // 如果关联了食谱，设置营养信息
        if (mealPlan.getRecipeId() != null) {
            Recipe recipe = recipeService.selectById(mealPlan.getRecipeId());
            if (recipe != null) {
                mealPlan.setCalories(recipe.getCalories());
                mealPlan.setRecipe(recipe);
            }
        }
        
        mealPlan.setIsCompleted(false);
        mealPlan.setCreateTime(LocalDateTime.now());
        mealPlan.setUpdateTime(LocalDateTime.now());
        return mealPlanMapper.insert(mealPlan) > 0;
    }
    
    @Override
    public boolean deleteById(Integer id) {
        return mealPlanMapper.deleteById(id) > 0;
    }
    
    @Override
    public boolean updateById(MealPlan mealPlan) {
        // 如果关联了食谱，更新营养信息
        if (mealPlan.getRecipeId() != null) {
            Recipe recipe = recipeService.selectById(mealPlan.getRecipeId());
            if (recipe != null) {
                mealPlan.setCalories(recipe.getCalories());
            }
        }
        
        mealPlan.setUpdateTime(LocalDateTime.now());
        return mealPlanMapper.updateById(mealPlan) > 0;
    }
    
    @Override
    public MealPlan selectById(Integer id) {
        MealPlan mealPlan = mealPlanMapper.selectById(id);
        // 加载关联的食谱信息
        if (mealPlan != null && mealPlan.getRecipeId() != null) {
            Recipe recipe = recipeService.selectById(mealPlan.getRecipeId());
            mealPlan.setRecipe(recipe);
        }
        return mealPlan;
    }
    
    @Override
    public List<MealPlan> selectByUserId(Integer userId) {
        List<MealPlan> mealPlans = mealPlanMapper.selectByUserId(userId);
        // 加载关联的食谱信息
        loadRecipeInfo(mealPlans);
        return mealPlans;
    }
    
    @Override
    public List<MealPlan> selectByDateRange(Integer userId, LocalDate startDate, LocalDate endDate) {
        List<MealPlan> mealPlans = mealPlanMapper.selectByDateRange(userId, startDate, endDate);
        // 加载关联的食谱信息
        loadRecipeInfo(mealPlans);
        return mealPlans;
    }
    
    @Override
    public boolean hasPlan(Integer userId, LocalDate planDate, String mealType) {
        return mealPlanMapper.countByDateAndType(userId, planDate, mealType) > 0;
    }
    
    @Override
    public boolean batchAdd(List<MealPlan> mealPlans) {
        // 批量设置创建时间和更新时间
        LocalDateTime now = LocalDateTime.now();
        for (MealPlan mealPlan : mealPlans) {
            mealPlan.setIsCompleted(false);
            mealPlan.setCreateTime(now);
            mealPlan.setUpdateTime(now);
            
            // 设置营养信息
            if (mealPlan.getRecipeId() != null) {
                Recipe recipe = recipeService.selectById(mealPlan.getRecipeId());
                if (recipe != null) {
                    mealPlan.setCalories(recipe.getCalories());
                }
            }
        }
        
        return mealPlanMapper.batchInsert(mealPlans) > 0;
    }
    
    @Override
    public boolean markAsCompleted(Integer mealPlanId, Boolean completed) {
        MealPlan mealPlan = new MealPlan();
        mealPlan.setId(mealPlanId);
        mealPlan.markAsCompleted(completed);
        mealPlan.setUpdateTime(LocalDateTime.now());
        return mealPlanMapper.updateById(mealPlan) > 0;
    }
    
    @Override
    public Map<String, Object> getDailyStatistics(Integer userId, LocalDate startDate, LocalDate endDate) {
        Map<String, Object> statistics = new HashMap<>();
        
        // 查询日期范围内的膳食计划
        List<MealPlan> mealPlans = selectByDateRange(userId, startDate, endDate);
        
        // 计算总卡路里
        int totalCalories = mealPlans.stream()
            .mapToInt(mp -> mp.getCalories() != null ? mp.getCalories() : 0)
            .sum();
        
        // 计算完成率
        long totalCount = mealPlans.size();
        long completedCount = mealPlans.stream()
            .filter(mp -> mp.getIsCompleted() != null && mp.getIsCompleted())
            .count();
        double completionRate = totalCount > 0 ? (completedCount * 100.0 / totalCount) : 0;
        
        // 按餐次统计
        Map<String, Integer> caloriesByMealType = new HashMap<>();
        Map<String, Integer> countByMealType = new HashMap<>();
        
        for (MealPlan mealPlan : mealPlans) {
            String mealType = mealPlan.getMealType();
            caloriesByMealType.put(mealType, caloriesByMealType.getOrDefault(mealType, 0) + 
                (mealPlan.getCalories() != null ? mealPlan.getCalories() : 0));
            countByMealType.put(mealType, countByMealType.getOrDefault(mealType, 0) + 1);
        }
        
        statistics.put("totalCalories", totalCalories);
        statistics.put("totalMeals", totalCount);
        statistics.put("completedMeals", completedCount);
        statistics.put("completionRate", completionRate);
        statistics.put("caloriesByMealType", caloriesByMealType);
        statistics.put("countByMealType", countByMealType);
        
        return statistics;
    }
    
    /**
     * 加载食谱信息
     * @param mealPlans 膳食计划列表
     */
    private void loadRecipeInfo(List<MealPlan> mealPlans) {
        // 收集所有食谱ID
        Set<Integer> recipeIds = mealPlans.stream()
            .filter(mp -> mp.getRecipeId() != null)
            .map(MealPlan::getRecipeId)
            .collect(Collectors.toSet());
        
        // 批量查询食谱信息
        Map<Integer, Recipe> recipeMap = new HashMap<>();
        for (Integer recipeId : recipeIds) {
            Recipe recipe = recipeService.selectById(recipeId);
            if (recipe != null) {
                recipeMap.put(recipeId, recipe);
            }
        }
        
        // 设置食谱信息
        for (MealPlan mealPlan : mealPlans) {
            if (mealPlan.getRecipeId() != null) {
                mealPlan.setRecipe(recipeMap.get(mealPlan.getRecipeId()));
            }
        }
    }
}
```

#### 2.3.4 NutritionAnalysisService接口及实现
```java
/**
 * 营养分析服务接口
 */
public interface NutritionAnalysisService {
    /**
     * 计算营养计划
     * @param user 用户对象
     * @return 营养计划响应
     */
    NutritionPlanResponse calculateNutritionPlan(User user);
    
    /**
     * 根据用户ID计算营养计划
     * @param userId 用户ID
     * @return 营养计划响应
     */
    NutritionPlanResponse calculateNutritionPlanById(Integer userId);
    
    /**
     * 推荐食谱
     * @param user 用户对象
     * @param mealType 餐次类型
     * @param limit 数量限制
     * @return 食谱列表
     */
    List<Recipe> recommendRecipes(User user, String mealType, Integer limit);
    
    /**
     * 生成膳食计划
     * @param user 用户对象
     * @param startDate 开始日期
     * @param days 天数
     * @return 膳食计划列表
     */
    List<MealPlan> generateMealPlan(User user, LocalDate startDate, Integer days);
    
    /**
     * 计算BMI
     * @param height 身高(cm)
     * @param weight 体重(kg)
     * @return BMI值
     */
    Double calculateBMI(Double height, Double weight);
    
    /**
     * 计算BMR（基础代谢率）
     * @param gender 性别
     * @param weight 体重(kg)
     * @param height 身高(cm)
     * @param age 年龄
     * @return BMR值
     */
    Double calculateBMR(String gender, Double weight, Double height, Integer age);
    
    /**
     * 计算TDEE（总能量消耗）
     * @param bmr 基础代谢率
     * @param activityLevel 活动水平
     * @return TDEE值
     */
    Double calculateTDEE(Double bmr, String activityLevel);
}

/**
 * 营养分析服务实现类
 */
@Service
public class NutritionAnalysisServiceImpl implements NutritionAnalysisService {
    @Autowired
    private UserService userService;
    
    @Autowired
    private RecipeService recipeService;
    
    @Autowired
    private MealPlanService mealPlanService;
    
    @Override
    public NutritionPlanResponse calculateNutritionPlan(User user) {
        NutritionPlanResponse response = new NutritionPlanResponse();
        
        // 计算BMI
        Double bmi = calculateBMI(user.getHeight(), user.getWeight());
        response.setBmi(bmi);
        
        // 设置BMI状态
        if (bmi != null) {
            if (bmi < 18.5) {
                response.setBmiStatus("偏瘦");
            } else if (bmi < 24) {
                response.setBmiStatus("正常");
            } else if (bmi < 28) {
                response.setBmiStatus("超重");
            } else {
                response.setBmiStatus("肥胖");
            }
        }
        
        // 计算BMR
        Double bmr = calculateBMR(user.getGender(), user.getWeight(), user.getHeight(), user.getAge());
        response.setBmr(bmr);
        
        // 计算TDEE
        Double tdee = calculateTDEE(bmr, user.getActivityLevel());
        response.setTdee(tdee);
        
        // 根据目标计算推荐卡路里摄入量
        Double recommendedCalories = calculateRecommendedCalories(tdee, user.getGoal());
        response.setRecommendedCalories(recommendedCalories);
        
        // 计算营养素需求
        Map<String, Double> nutrientRequirements = calculateNutrientRequirements(recommendedCalories);
        response.setNutrientRequirements(nutrientRequirements);
        
        // 生成营养建议
        response.setNutritionAdvice(generateNutritionAdvice(user, bmi, user.getGoal()));
        
        return response;
    }
    
    @Override
    public NutritionPlanResponse calculateNutritionPlanById(Integer userId) {
        User user = userService.selectById(userId);
        if (user == null) {
            throw new RuntimeException("用户不存在");
        }
        return calculateNutritionPlan(user);
    }
    
    @Override
    public List<Recipe> recommendRecipes(User user, String mealType, Integer limit) {
        // 计算营养需求
        NutritionPlanResponse nutritionPlan = calculateNutritionPlan(user);
        Double recommendedCalories = nutritionPlan.getRecommendedCalories();
        
        // 根据餐次类型计算卡路里范围
        Map<String, Integer> calorieRange = calculateCalorieRangeForMeal(recommendedCalories, mealType);
        
        // 获取推荐食谱
        return recipeService.recommendByNutrition(calorieRange, mealType, limit);
    }
    
    @Override
    public List<MealPlan> generateMealPlan(User user, LocalDate startDate, Integer days) {
        List<MealPlan> generatedPlans = new ArrayList<>();
        
        // 计算营养需求
        NutritionPlanResponse nutritionPlan = calculateNutritionPlan(user);
        
        // 餐次类型列表
        List<String> mealTypes = Arrays.asList("早餐", "午餐", "晚餐", "加餐");
        
        for (int day = 0; day < days; day++) {
            LocalDate currentDate = startDate.plusDays(day);
            
            for (String mealType : mealTypes) {
                // 检查是否已有计划
                if (mealPlanService.hasPlan(user.getId(), currentDate, mealType)) {
                    continue;
                }
                
                // 根据餐次类型获取推荐食谱
                List<Recipe> recommendedRecipes = recommendRecipes(user, mealType, 5);
                
                if (!recommendedRecipes.isEmpty()) {
                    // 随机选择一个食谱
                    Recipe selectedRecipe = recommendedRecipes.get(new Random().nextInt(recommendedRecipes.size()));
                    
                    // 创建膳食计划
                    MealPlan mealPlan = new MealPlan();
                    mealPlan.setUserId(user.getId());
                    mealPlan.setPlanName("自动生成 - " + mealType);
                    mealPlan.setPlanDate(currentDate);
                    mealPlan.setMealType(mealType);
                    mealPlan.setRecipeId(selectedRecipe.getId());
                    mealPlan.setCalories(selectedRecipe.getCalories());
                    
                    generatedPlans.add(mealPlan);
                }
            }
        }
        
        // 批量保存膳食计划
        if (!generatedPlans.isEmpty()) {
            mealPlanService.batchAdd(generatedPlans);
        }
        
        return generatedPlans;
    }
    
    @Override
    public Double calculateBMI(Double height, Double weight) {
        if (height == null || weight == null || height <= 0 || weight <= 0) {
            return null;
        }
        return weight / Math.pow(height / 100, 2);
    }
    
    @Override
    public Double calculateBMR(String gender, Double weight, Double height, Integer age) {
        if (gender == null || weight == null || height == null || age == null) {
            return null;
        }
        
        // 使用Mifflin-St Jeor公式计算BMR
        if ("男".equals(gender)) {
            return (10 * weight) + (6.25 * height) - (5 * age) + 5;
        } else {
            return (10 * weight) + (6.25 * height) - (5 * age) - 161;
        }
    }
    
    @Override
    public Double calculateTDEE(Double bmr, String activityLevel) {
        if (bmr == null || activityLevel == null) {
            return null;
        }
        
        // 根据活动水平计算TDEE
        switch (activityLevel) {
            case "久坐不动":
                return bmr * 1.2;
            case "轻度活动": // 每周1-3次运动
                return bmr * 1.375;
            case "中度活动": // 每周3-5次运动
                return bmr * 1.55;
            case "高度活动": // 每周6-7次运动
                return bmr * 1.725;
            case "非常活跃": // 体力劳动或每天高强度训练
                return bmr * 1.9;
            default:
                return bmr * 1.2;
        }
    }
    
    /**
     * 根据目标计算推荐卡路里摄入量
     * @param tdee 总能量消耗
     * @param goal 健康目标
     * @return 推荐卡路里摄入量
     */
    private Double calculateRecommendedCalories(Double tdee, String goal) {
        if (tdee == null) {
            return null;
        }
        
        switch (goal) {
            case "减脂":
                return tdee * 0.85; // 减少15%
            case "增肌":
                return tdee * 1.10; // 增加10%
            case "维持体重":
            default:
                return tdee;
        }
    }
    
    /**
     * 计算营养素需求
     * @param calories 卡路里摄入量
     * @return 营养素需求
     */
    private Map<String, Double> calculateNutrientRequirements(Double calories) {
        Map<String, Double> requirements = new HashMap<>();
        
        if (calories == null) {
            return requirements;
        }
        
        // 蛋白质：总热量的20-25%
        double protein = calories * 0.225 / 4; // 每克蛋白质提供4卡路里
        
        // 碳水化合物：总热量的45-55%
        double carbs = calories * 0.50 / 4; // 每克碳水化合物提供4卡路里
        
        // 脂肪：总热量的20-30%
        double fat = calories * 0.25 / 9; // 每克脂肪提供9卡路里
        
        // 膳食纤维：每日推荐25-35克
        double fiber = 30.0;
        
        // 水分：体重(kg) * 35-40ml
        // 这里使用默认值，实际应根据体重计算
        double water = 2500.0; // ml
        
        requirements.put("protein", protein);
        requirements.put("carbs", carbs);
        requirements.put("fat", fat);
        requirements.put("fiber", fiber);
        requirements.put("water", water);
        
        return requirements;
    }
    
    /**
     * 生成营养建议
     * @param user 用户信息
     * @param bmi BMI值
     * @param goal 健康目标
     * @return 营养建议
     */
    private String generateNutritionAdvice(User user, Double bmi, String goal) {
        StringBuilder advice = new StringBuilder();
        
        // 根据BMI给出建议
        if (bmi != null) {
            if (bmi < 18.5) {
                advice.append("您的BMI偏瘦，建议适当增加热量摄入，多吃富含优质蛋白质和健康脂肪的食物。\n");
            } else if (bmi < 24) {
                advice.append("您的BMI正常，请继续保持健康的饮食习惯和生活方式。\n");
            } else if (bmi < 28) {
                advice.append("您的BMI超重，建议控制热量摄入，增加膳食纤维摄入，减少高脂肪、高糖分食物。\n");
            } else {
                advice.append("您的BMI属于肥胖范围，强烈建议咨询专业营养师，制定个性化的减重计划。\n");
            }
        }
        
        // 根据目标给出建议
        switch (goal) {
            case "减脂":
                advice.append("减脂期间，建议增加蛋白质摄入，控制碳水化合物的质和量，选择低GI食物，保证充分饮水。\n");
                break;
            case "增肌":
                advice.append("增肌期间，建议增加优质蛋白质摄入，合理安排碳水化合物补充，保证足够的热量盈余。\n");
                break;
            case "维持体重":
                advice.append("维持体重期间，建议保持饮食均衡，控制食物分量，定期监测体重变化。\n");
                break;
        }
        
        advice.append("每日饮水量建议保持在2000-2500ml，保证充足睡眠，适量运动。");
        
        return advice.toString();
    }
    
    /**
     * 计算餐次的卡路里范围
     * @param dailyCalories 每日总卡路里
     * @param mealType 餐次类型
     * @return 卡路里范围
     */
    private Map<String, Integer> calculateCalorieRangeForMeal(Double dailyCalories, String mealType) {
        Map<String, Integer> range = new HashMap<>();
        
        if (dailyCalories == null) {
            range.put("min", 0);
            range.put("max", 1000);
            return range;
        }
        
        // 根据餐次类型分配卡路里比例
        double percentage = 0.30; // 默认30%
        
        switch (mealType) {
            case "早餐":
                percentage = 0.25; // 25%
                break;
            case "午餐":
                percentage = 0.35; // 35%
                break;
            case "晚餐":
                percentage = 0.30; // 30%
                break;
            case "加餐":
                percentage = 0.10; // 10%
                break;
        }
        
        int targetCalories = (int) (dailyCalories * percentage);
        
        // 设置±20%的范围
        range.put("min", (int) (targetCalories * 0.8));
        range.put("max", (int) (targetCalories * 1.2));
        
        return range;
    }
}
```

## 3. 算法流程设计

### 3.1 营养计算算法

#### 3.1.1 BMI计算算法
**功能说明**：计算用户的体重指数（BMI），用于评估体重是否健康。

**算法步骤**：
1. 输入：身高（cm）、体重（kg）
2. 验证输入参数有效性
3. 将身高转换为米（m）
4. 使用公式：BMI = 体重(kg) / 身高(m)²
5. 根据BMI值返回对应的健康状态

**代码实现**：
```java
public Double calculateBMI(Double height, Double weight) {
    // 参数验证
    if (height == null || weight == null || height <= 0 || weight <= 0) {
        return null;
    }
    
    // 身高单位转换：cm -> m
    double heightInMeters = height / 100.0;
    
    // 计算BMI
    double bmi = weight / (heightInMeters * heightInMeters);
    
    // 保留1位小数
    return Math.round(bmi * 10) / 10.0;
}
```

#### 3.1.2 BMR计算算法
**功能说明**：计算用户的基础代谢率（BMR），即维持基本生理功能所需的最低能量消耗。

**算法步骤**：
1. 输入：性别、体重（kg）、身高（cm）、年龄
2. 验证输入参数有效性
3. 使用Mifflin-St Jeor公式计算BMR：
   - 男性：BMR = 10 × 体重(kg) + 6.25 × 身高(cm) - 5 × 年龄 + 5
   - 女性：BMR = 10 × 体重(kg) + 6.25 × 身高(cm) - 5 × 年龄 - 161
4. 返回BMR值（卡路里/天）

**代码实现**：
```java
public Double calculateBMR(String gender, Double weight, Double height, Integer age) {
    // 参数验证
    if (gender == null || weight == null || height == null || age == null) {
        return null;
    }
    
    double bmr;
    if ("男".equals(gender)) {
        bmr = (10 * weight) + (6.25 * height) - (5 * age) + 5;
    } else {
        bmr = (10 * weight) + (6.25 * height) - (5 * age) - 161;
    }
    
    return Math.round(bmr * 10) / 10.0;
}
```

#### 3.1.3 TDEE计算算法
**功能说明**：计算用户的总能量消耗（TDEE），即每天消耗的总卡路里。

**算法步骤**：
1. 输入：BMR值、活动水平
2. 验证输入参数有效性
3. 根据活动水平选择对应的活动系数：
   - 久坐不动：1.2
   - 轻度活动（每周1-3次运动）：1.375
   - 中度活动（每周3-5次运动）：1.55
   - 高度活动（每周6-7次运动）：1.725
   - 非常活跃（体力劳动或每天高强度训练）：1.9
4. TDEE = BMR × 活动系数
5. 返回TDEE值（卡路里/天）

**代码实现**：
```java
public Double calculateTDEE(Double bmr, String activityLevel) {
    // 参数验证
    if (bmr == null || activityLevel == null) {
        return null;
    }
    
    // 活动系数映射
    Map<String, Double> activityFactors = new HashMap<>();
    activityFactors.put("久坐不动", 1.2);
    activityFactors.put("轻度活动", 1.375);
    activityFactors.put("中度活动", 1.55);
    activityFactors.put("高度活动", 1.725);
    activityFactors.put("非常活跃", 1.9);
    
    // 获取活动系数
    double factor = activityFactors.getOrDefault(activityLevel, 1.2);
    
    // 计算TDEE
    double tdee = bmr * factor;
    
    return Math.round(tdee * 10) / 10.0;
}
```

### 3.2 营养成分分析算法

**功能说明**：分析食谱或膳食计划的营养成分，计算各项营养素含量。

**算法步骤**：
1. 输入：食谱ID或膳食计划对象
2. 解析食谱配料信息
3. 根据食物成分数据库，计算每种配料的营养成分
4. 累加计算总营养成分
5. 计算营养素占推荐摄入量的百分比
6. 生成营养分析报告

**代码实现**：
```java
public NutritionAnalysis analyzeRecipeNutrition(Integer recipeId) {
    Recipe recipe = recipeService.getById(recipeId);
    if (recipe == null) {
        return null;
    }
    
    NutritionAnalysis analysis = new NutritionAnalysis();
    analysis.setRecipeId(recipeId);
    analysis.setRecipeName(recipe.getName());
    
    // 解析配料
    List<Ingredient> ingredients = parseIngredients(recipe.getIngredients());
    
    // 计算营养成分
    Map<String, Double> totalNutrients = calculateTotalNutrients(ingredients);
    
    // 设置分析结果
    analysis.setCalories(totalNutrients.getOrDefault("calories", 0.0).intValue());
    analysis.setProtein(totalNutrients.getOrDefault("protein", 0.0));
    analysis.setCarbohydrate(totalNutrients.getOrDefault("carbohydrate", 0.0));
    analysis.setFat(totalNutrients.getOrDefault("fat", 0.0));
    analysis.setFiber(totalNutrients.getOrDefault("fiber", 0.0));
    analysis.setSugar(totalNutrients.getOrDefault("sugar", 0.0));
    analysis.setSodium(totalNutrients.getOrDefault("sodium", 0.0));
    
    // 计算营养素比例
    calculateNutrientRatios(analysis);
    
    return analysis;
}

/**
 * 计算总营养成分
 */
private Map<String, Double> calculateTotalNutrients(List<Ingredient> ingredients) {
    Map<String, Double> totalNutrients = new HashMap<>();
    
    for (Ingredient ingredient : ingredients) {
        // 从食物成分数据库获取营养信息
        Map<String, Double> foodNutrients = foodDatabaseService.getFoodNutrition(
            ingredient.getName(), ingredient.getAmount(), ingredient.getUnit());
        
        // 累加到总营养成分
        for (Map.Entry<String, Double> entry : foodNutrients.entrySet()) {
            totalNutrients.put(entry.getKey(), 
                totalNutrients.getOrDefault(entry.getKey(), 0.0) + entry.getValue());
        }
    }
    
    return totalNutrients;
}
```

## 4. 数据结构设计

### 4.1 核心数据模型

#### 4.1.1 用户健康数据模型
```java
/**
 * 用户健康数据模型
 * 用于存储和计算用户的健康指标
 */
public class HealthData {
    private Double height;           // 身高(cm)
    private Double weight;           // 体重(kg)
    private Integer age;             // 年龄
    private String gender;           // 性别
    private String activityLevel;    // 活动水平
    private String physicalStatus;   // 身体状态
    private String dietaryRestrictions; // 饮食禁忌
    private String goal;             // 健康目标
    
    // 衍生字段
    private Double bmi;              // BMI
    private Double bmr;              // 基础代谢率
    private Double tdee;             // 总能量消耗
    
    // getter和setter方法
    // ...
    
    /**
     * 更新衍生指标
     */
    public void updateDerivedMetrics() {
        if (height != null && weight != null) {
            this.bmi = calculateBMI(height, weight);
        }
        if (gender != null && weight != null && height != null && age != null) {
            this.bmr = calculateBMR(gender, weight, height, age);
        }
        if (bmr != null && activityLevel != null) {
            this.tdee = calculateTDEE(bmr, activityLevel);
        }
    }
}
```

#### 4.1.2 食谱配料模型
```java
/**
 * 食谱配料模型
 * 用于表示食谱中的单个配料
 */
public class Ingredient {
    private String name;             // 配料名称
    private Double amount;           // 数量
    private String unit;             // 单位
    private String preparation;      // 预处理说明
    private Map<String, Double> nutrients; // 营养成分
    
    // getter和setter方法
    // ...
    
    /**
     * 解析JSON格式的配料字符串
     */
    public static List<Ingredient> parseIngredients(String jsonString) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(jsonString, new TypeReference<List<Ingredient>>() {});
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }
    
    /**
     * 转换为JSON字符串
     */
    public static String toJsonString(List<Ingredient> ingredients) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.writeValueAsString(ingredients);
        } catch (Exception e) {
            return "[]";
        }
    }
}
```

#### 4.1.3 营养计划模型
```java
/**
 * 营养计划模型
 * 存储用户的营养需求和推荐摄入量
 */
public class NutritionPlan {
    private Integer userId;              // 用户ID
    private Double recommendedCalories;  // 推荐卡路里摄入量
    private Map<String, Double> nutrientRequirements; // 营养素需求
    private Map<String, Double> dailyIntakeGoals; // 每日摄入目标
    private String nutritionAdvice;      // 营养建议
    private LocalDateTime createTime;    // 创建时间
    private LocalDateTime updateTime;    // 更新时间
    
    // getter和setter方法
    // ...
    
    /**
     * 根据目标调整推荐摄入量
     */
    public void adjustForGoal(String goal) {
        switch (goal) {
            case "减重":
                recommendedCalories *= 0.85; // 减少15%卡路里
                break;
            case "增肌":
                recommendedCalories *= 1.10; // 增加10%卡路里
                nutrientRequirements.put("protein", nutrientRequirements.getOrDefault("protein", 0.0) * 1.2);
                break;
            case "维持体重":
                // 维持当前推荐量
                break;
            default:
                // 默认维持体重
        }
    }
    
    /**
     * 生成营养建议
     */
    public void generateAdvice() {
        StringBuilder advice = new StringBuilder();
        
        // 基于营养目标生成建议
        advice.append("根据您的身体状况和健康目标，建议每日摄入")
              .append(Math.round(recommendedCalories))
              .append("卡路里。");
        
        // 添加营养素建议
        Double protein = nutrientRequirements.getOrDefault("protein", 0.0);
        Double carbs = nutrientRequirements.getOrDefault("carbohydrate", 0.0);
        Double fat = nutrientRequirements.getOrDefault("fat", 0.0);
        
        advice.append("蛋白质摄入建议：")
              .append(String.format("%.1f", protein))
              .append("g；碳水化合物：")
              .append(String.format("%.1f", carbs))
              .append("g；脂肪：")
              .append(String.format("%.1f", fat))
              .append("g。");
        
        this.nutritionAdvice = advice.toString();
    }
}
```

### 4.2 集合数据结构使用

#### 4.2.1 高效数据存储结构
```java
/**
 * 食谱索引类
 * 使用高效的数据结构存储和检索食谱
 */
public class RecipeIndex {
    // 分类索引：快速按分类查找食谱
    private Map<String, List<Integer>> categoryIndex = new HashMap<>();
    
    // 营养成分索引：用于营养筛选
    private NavigableMap<Integer, Set<Integer>> calorieIndex = new TreeMap<>();
    
    // 名称索引：用于快速搜索
    private Trie recipeNameTrie = new Trie();
    
    // 配料倒排索引：用于按配料搜索
    private Map<String, Set<Integer>> ingredientInvertedIndex = new HashMap<>();
    
    /**
     * 添加食谱到索引
     */
    public void addRecipe(Recipe recipe) {
        // 添加到分类索引
        String category = recipe.getCategory();
        categoryIndex.computeIfAbsent(category, k -> new ArrayList<>()).add(recipe.getId());
        
        // 添加到卡路里索引
        Integer calories = recipe.getCalories();
        calorieIndex.computeIfAbsent(calories, k -> new HashSet<>()).add(recipe.getId());
        
        // 添加到名称索引
        recipeNameTrie.insert(recipe.getName(), recipe.getId());
        
        // 添加到配料索引
        List<String> ingredients = extractIngredients(recipe.getIngredients());
        for (String ingredient : ingredients) {
            ingredientInvertedIndex.computeIfAbsent(ingredient, k -> new HashSet<>()).add(recipe.getId());
        }
    }
    
    /**
     * 根据卡路里范围查询食谱ID
     */
    public Set<Integer> findByCalorieRange(int minCalories, int maxCalories) {
        Set<Integer> result = new HashSet<>();
        Map<Integer, Set<Integer>> subMap = calorieIndex.subMap(minCalories, true, maxCalories, true);
        
        for (Set<Integer> recipeIds : subMap.values()) {
            result.addAll(recipeIds);
        }
        
        return result;
    }
    
    /**
     * 根据名称前缀搜索食谱
     */
    public List<Integer> searchByNamePrefix(String prefix) {
        return recipeNameTrie.searchByPrefix(prefix);
    }
}

/**
 * Trie树实现
 * 用于高效的字符串前缀匹配
 */
class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    /**
     * 插入单词和关联ID
     */
    public void insert(String word, Integer id) {
        TrieNode node = root;
        for (char c : word.toLowerCase().toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.isEndOfWord = true;
        node.ids.add(id);
    }
    
    /**
     * 根据前缀搜索
     */
    public List<Integer> searchByPrefix(String prefix) {
        List<Integer> result = new ArrayList<>();
        TrieNode node = root;
        
        // 遍历前缀
        for (char c : prefix.toLowerCase().toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return result; // 前缀不存在
            }
            node = node.children[index];
        }
        
        // 收集所有以该前缀开头的单词ID
        collectAllIds(node, result);
        return result;
    }
    
    /**
     * 收集节点下所有ID
     */
    private void collectAllIds(TrieNode node, List<Integer> result) {
        if (node.isEndOfWord) {
            result.addAll(node.ids);
        }
        
        for (TrieNode child : node.children) {
            if (child != null) {
                collectAllIds(child, result);
            }
        }
    }
    
    /**
     * Trie节点
     */
    private static class TrieNode {
        private TrieNode[] children;
        private boolean isEndOfWord;
        private List<Integer> ids;
        
        public TrieNode() {
            children = new TrieNode[26]; // 假设只包含小写字母
            isEndOfWord = false;
            ids = new ArrayList<>();
        }
    }
}
```

### 4.3 缓存数据结构设计

#### 4.3.1 多级缓存设计
```java
/**
 * 自定义内存缓存管理器
 * 使用本地内存实现缓存功能
 */
public class RecipeCacheService {
    // 本地内存缓存
    private LoadingCache<String, Object> cache;
    
    public RecipeCacheService() {
        // 初始化本地缓存
        this.cache = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .recordStats()
            .build(new CacheLoader<String, Object>() {
                @Override
                public Object load(String key) {
                    // 缓存未命中，返回null
                    return null;
                }
            });
    }
    
    /**
     * 获取缓存
     */
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        try {
            // 查询本地缓存
            Object value = cache.getIfPresent(key);
            if (value != null) {
                return type.cast(value);
            }
        } catch (Exception e) {
            // 缓存异常处理
        }
        
        return null;
    }
    
    /**
     * 设置缓存
     */
    public void set(String key, Object value, long expireTime, TimeUnit timeUnit) {
        // 更新本地缓存
        try {
            cache.put(key, value);
        } catch (Exception ignored) {
        }
    }
    
    /**
     * 删除缓存
     */
    public void delete(String key) {
        // 删除本地缓存
        cache.invalidate(key);
    }
    
    /**
     * 清理过期缓存
     */
    public void cleanExpired() {
        // 缓存会自动清理过期项
    }
}

/**
 * 缓存键生成器
 */
public class CacheKeyGenerator {
    private static final String USER_PREFIX = "user:";
    private static final String RECIPE_PREFIX = "recipe:";
    private static final String MEAL_PLAN_PREFIX = "meal_plan:";
    private static final String NUTRITION_PREFIX = "nutrition:";
    
    /**
     * 生成用户缓存键
     */
    public static String getUserKey(Integer userId) {
        return USER_PREFIX + "info:" + userId;
    }
    
    /**
     * 生成食谱缓存键
     */
    public static String getRecipeKey(Integer recipeId) {
        return RECIPE_PREFIX + "detail:" + recipeId;
    }
    
    /**
     * 生成膳食计划缓存键
     */
    public static String getMealPlanKey(Integer userId, Date date) {
        String dateStr = new SimpleDateFormat("yyyyMMdd").format(date);
        return MEAL_PLAN_PREFIX + "daily:" + userId + ":" + dateStr;
    }
    
    /**
     * 生成营养计划缓存键
     */
    public static String getNutritionPlanKey(Integer userId) {
        return NUTRITION_PREFIX + "plan:" + userId;
    }
}
```

### 4.4 数据序列化与反序列化

#### 4.4.1 高效JSON处理
```java
/**
 * JSON工具类
 * 提供高效的JSON序列化和反序列化功能
 */
public class JsonUtils {
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
    
    static {
        // 配置ObjectMapper
        OBJECT_MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        OBJECT_MAPPER.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        OBJECT_MAPPER.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        
        // 注册Java 8日期时间模块
        OBJECT_MAPPER.registerModule(new JavaTimeModule());
    }
    
    /**
     * 对象转JSON字符串
     */
    public static String toJson(Object object) {
        try {
            return OBJECT_MAPPER.writeValueAsString(object);
        } catch (Exception e) {
            throw new RuntimeException("JSON序列化失败", e);
        }
    }
    
    /**
     * JSON字符串转对象
     */
    @SuppressWarnings("unchecked")
    public static <T> T fromJson(String json, Class<T> clazz) {
        try {
            return OBJECT_MAPPER.readValue(json, clazz);
        } catch (Exception e) {
            throw new RuntimeException("JSON反序列化失败", e);
        }
    }
    
    /**
     * JSON字符串转集合
     */
    @SuppressWarnings("unchecked")
    public static <T> List<T> fromJsonToList(String json, Class<T> elementType) {
        try {
            JavaType type = OBJECT_MAPPER.getTypeFactory().constructCollectionType(List.class, elementType);
            return OBJECT_MAPPER.readValue(json, type);
        } catch (Exception e) {
            throw new RuntimeException("JSON转集合失败", e);
        }
    }
    
    /**
     * JSON字符串转Map
     */
    @SuppressWarnings("unchecked")
    public static <K, V> Map<K, V> fromJsonToMap(String json, Class<K> keyType, Class<V> valueType) {
        try {
            JavaType type = OBJECT_MAPPER.getTypeFactory().constructMapType(Map.class, keyType, valueType);
            return OBJECT_MAPPER.readValue(json, type);
        } catch (Exception e) {
            throw new RuntimeException("JSON转Map失败", e);
        }
    }
}

```

## 5. 数据库详细设计

### 5.1 数据库表结构

#### 5.1.1 `account`表

| 字段名             | 数据类型      | 约束                                                         | 描述                               |
| :----------------- | :------------ | :----------------------------------------------------------- | :--------------------------------- |
| `id`               | `INT`         | `PRIMARY KEY AUTO_INCREMENT`                                 | 账户ID                             |
| `user_id`          | `INT`         | `UNIQUE NOT NULL, FOREIGN KEY REFERENCES user(id)`           | 用户ID                             |
| `account_status`   | `VARCHAR(20)` | `NOT NULL DEFAULT 'active'`                                  | 账户状态（active/inactive/locked） |
| `last_login_ip`    | `VARCHAR(50)` |                                                              | 最后登录IP                         |
| `last_login_time`  | `DATETIME`    |                                                              | 最后登录时间                       |
| `login_fail_count` | `INT`         | `NOT NULL DEFAULT 0`                                         | 登录失败次数                       |
| `lock_time`        | `DATETIME`    |                                                              | 锁定时间                           |
| `create_time`      | `DATETIME`    | `NOT NULL DEFAULT CURRENT_TIMESTAMP`                         | 创建时间                           |
| `update_time`      | `DATETIME`    | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间                           |

**创建表SQL**：
```sql
CREATE TABLE `account` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `user_id` INT NOT NULL UNIQUE,
  `account_status` VARCHAR(20) NOT NULL DEFAULT 'active',
  `last_login_ip` VARCHAR(50),
  `last_login_time` DATETIME,
  `login_fail_count` INT NOT NULL DEFAULT 0,
  `lock_time` DATETIME,
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 5.1.2 `user`表

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `INT` | `PRIMARY KEY AUTO_INCREMENT` | 用户ID |
| `username` | `VARCHAR(50)` | `UNIQUE NOT NULL` | 用户名 |
| `password` | `VARCHAR(255)` | `NOT NULL` | 密码（加密存储） |
| `name` | `VARCHAR(100)` | `NOT NULL` | 姓名 |
| `phone` | `VARCHAR(20)` | | 手机号 |
| `email` | `VARCHAR(100)` | | 邮箱 |
| `gender` | `VARCHAR(10)` | | 性别 |
| `age` | `INT` | | 年龄 |
| `height` | `DOUBLE` | | 身高(cm) |
| `weight` | `DOUBLE` | | 体重(kg) |
| `bmi` | `DOUBLE` | | BMI值 |
| `physical_status` | `VARCHAR(20)` | | 身体状态 |
| `activity_level` | `VARCHAR(20)` | | 活动水平 |
| `goal` | `VARCHAR(20)` | | 健康目标 |
| `role` | `VARCHAR(20)` | `NOT NULL DEFAULT 'user'` | 角色 |
| `health_data_update_time` | `DATETIME` | | 健康数据更新时间 |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**创建表SQL**：
```sql
CREATE TABLE `user` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL UNIQUE,
  `password` VARCHAR(255) NOT NULL,
  `name` VARCHAR(100) NOT NULL,
  `phone` VARCHAR(20),
  `email` VARCHAR(100),
  `gender` VARCHAR(10),
  `age` INT,
  `height` DOUBLE,
  `weight` DOUBLE,
  `bmi` DOUBLE,
  `physical_status` VARCHAR(20),
  `activity_level` VARCHAR(20),
  `goal` VARCHAR(20),
  `role` VARCHAR(20) NOT NULL DEFAULT 'user',
  `health_data_update_time` DATETIME,
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 5.1.3 `recipe`表

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `INT` | `PRIMARY KEY AUTO_INCREMENT` | 食谱ID |
| `name` | `VARCHAR(200)` | `NOT NULL` | 食谱名称 |
| `description` | `TEXT` | | 食谱描述 |
| `ingredients` | `TEXT` | `NOT NULL` | 食材列表（JSON格式） |
| `instructions` | `TEXT` | `NOT NULL` | 制作步骤（JSON格式） |
| `cooking_time` | `INT` | | 烹饪时间（分钟） |
| `preparation_time` | `INT` | | 准备时间（分钟） |
| `servings` | `INT` | | 份量 |
| `calories` | `INT` | `NOT NULL` | 卡路里 |
| `protein` | `DOUBLE` | | 蛋白质(克) |
| `carbs` | `DOUBLE` | | 碳水化合物(克) |
| `fat` | `DOUBLE` | | 脂肪(克) |
| `fiber` | `DOUBLE` | | 膳食纤维(克) |
| `category` | `VARCHAR(50)` | `NOT NULL` | 分类 |
| `meal_type` | `VARCHAR(20)` | | 餐次类型 |
| `image_url` | `VARCHAR(500)` | | 图片URL |
| `view_count` | `INT` | `NOT NULL DEFAULT 0` | 浏览次数 |
| `favorite_count` | `INT` | `NOT NULL DEFAULT 0` | 收藏次数 |
| `comment_count` | `INT` | `NOT NULL DEFAULT 0` | 评论次数 |
| `is_published` | `BOOLEAN` | `NOT NULL DEFAULT TRUE` | 是否发布 |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**创建表SQL**：
```sql
CREATE TABLE `recipe` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(200) NOT NULL,
  `description` TEXT,
  `ingredients` TEXT NOT NULL,
  `instructions` TEXT NOT NULL,
  `cooking_time` INT,
  `preparation_time` INT,
  `servings` INT,
  `calories` INT NOT NULL,
  `protein` DOUBLE,
  `carbs` DOUBLE,
  `fat` DOUBLE,
  `fiber` DOUBLE,
  `category` VARCHAR(50) NOT NULL,
  `meal_type` VARCHAR(20),
  `image_url` VARCHAR(500),
  `view_count` INT NOT NULL DEFAULT 0,
  `favorite_count` INT NOT NULL DEFAULT 0,
  `comment_count` INT NOT NULL DEFAULT 0,
  `is_published` BOOLEAN NOT NULL DEFAULT TRUE,
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 5.1.4 `meal_plan`表

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `INT` | `PRIMARY KEY AUTO_INCREMENT` | 膳食计划ID |
| `user_id` | `INT` | `NOT NULL, FOREIGN KEY REFERENCES user(id)` | 用户ID |
| `plan_name` | `VARCHAR(200)` | `NOT NULL` | 计划名称 |
| `plan_date` | `DATE` | `NOT NULL` | 计划日期 |
| `meal_type` | `VARCHAR(20)` | `NOT NULL` | 餐次类型 |
| `recipe_id` | `INT` | `FOREIGN KEY REFERENCES recipe(id)` | 食谱ID |
| `custom_meal` | `TEXT` | | 自定义膳食内容 |
| `calories` | `INT` | | 卡路里 |
| `notes` | `TEXT` | | 备注 |
| `is_completed` | `BOOLEAN` | `NOT NULL DEFAULT FALSE` | 是否完成 |
| `completion_time` | `VARCHAR(20)` | | 完成时间 |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**创建表SQL**：
```sql
CREATE TABLE `meal_plan` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `user_id` INT NOT NULL,
  `plan_name` VARCHAR(200) NOT NULL,
  `plan_date` DATE NOT NULL,
  `meal_type` VARCHAR(20) NOT NULL,
  `recipe_id` INT,
  `custom_meal` TEXT,
  `calories` INT,
  `notes` TEXT,
  `is_completed` BOOLEAN NOT NULL DEFAULT FALSE,
  `completion_time` VARCHAR(20),
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`recipe_id`) REFERENCES `recipe`(`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 5.2 索引设计

#### 5.2.1 主键索引
- 每个表的`id`字段都设置了主键索引，用于快速查找和唯一标识记录

#### 5.2.2 唯一索引
- `user`表：`username`字段设置唯一索引，确保用户名不重复
- `account`表：`user_id`字段设置唯一索引，确保一个用户只有一个账户

#### 5.2.3 普通索引

**用户表索引**：
```sql
-- 优化用户登录查询
CREATE INDEX `idx_user_username` ON `user`(`username`);

-- 优化健康数据分析查询
CREATE INDEX `idx_user_health_data` ON `user`(`bmi`, `physical_status`, `activity_level`, `goal`);
```

**食谱表索引**：
```sql
-- 优化食谱搜索
CREATE INDEX `idx_recipe_name` ON `recipe`(`name`);
CREATE FULLTEXT INDEX `ft_idx_recipe_search` ON `recipe`(`name`, `description`, `ingredients`);

-- 优化按分类查询
CREATE INDEX `idx_recipe_category` ON `recipe`(`category`);

-- 优化按餐次类型查询
CREATE INDEX `idx_recipe_meal_type` ON `recipe`(`meal_type`);

-- 优化营养筛选
CREATE INDEX `idx_recipe_nutrition` ON `recipe`(`calories`);

-- 优化热门食谱查询
CREATE INDEX `idx_recipe_popularity` ON `recipe`(`view_count` DESC, `favorite_count` DESC);
```

**膳食计划表索引**：
```sql
-- 优化用户膳食计划查询
CREATE INDEX `idx_meal_plan_user` ON `meal_plan`(`user_id`);

-- 优化日期范围查询
CREATE INDEX `idx_meal_plan_date` ON `meal_plan`(`plan_date`);

-- 复合索引优化特定用户特定日期的查询
CREATE INDEX `idx_meal_plan_user_date` ON `meal_plan`(`user_id`, `plan_date`);

-- 优化餐次类型查询
CREATE INDEX `idx_meal_plan_type` ON `meal_plan`(`meal_type`);

-- 复合索引优化用户特定日期特定餐次的查询
CREATE INDEX `idx_meal_plan_user_date_type` ON `meal_plan`(`user_id`, `plan_date`, `meal_type`);
```

### 5.3 SQL语句示例

#### 5.3.1 用户管理相关SQL

**用户注册**：
```sql
INSERT INTO `user` (`username`, `password`, `name`, `phone`, `email`, `gender`, `age`) 
VALUES (?, ?, ?, ?, ?, ?, ?);

-- 注册成功后创建账户
INSERT INTO `account` (`user_id`) VALUES (LAST_INSERT_ID());
```

**用户登录验证**：
```sql
SELECT u.`id`, u.`username`, u.`password`, u.`role`, a.`account_status`, a.`login_fail_count` 
FROM `user` u 
JOIN `account` a ON u.`id` = a.`user_id` 
WHERE u.`username` = ?;
```

**更新用户健康数据**：
```sql
UPDATE `user` SET 
  `height` = ?, 
  `weight` = ?, 
  `bmi` = ?, 
  `physical_status` = ?, 
  `activity_level` = ?, 
  `goal` = ?, 
  `health_data_update_time` = NOW(),
  `update_time` = NOW() 
WHERE `id` = ?;
```

#### 5.3.2 食谱管理相关SQL

**查询食谱详情**：
```sql
SELECT * FROM `recipe` WHERE `id` = ? AND `is_published` = TRUE;

-- 增加浏览次数
UPDATE `recipe` SET `view_count` = `view_count` + 1, `update_time` = NOW() WHERE `id` = ?;
```

**搜索食谱**：
```sql
-- 按关键词搜索（支持模糊匹配）
SELECT * FROM `recipe` 
WHERE `is_published` = TRUE 
  AND (`name` LIKE ? OR `description` LIKE ? OR `ingredients` LIKE ?)
LIMIT ? OFFSET ?;

-- 全文搜索（更高效）
SELECT * FROM `recipe` 
WHERE `is_published` = TRUE 
  AND MATCH(`name`, `description`, `ingredients`) AGAINST(? IN NATURAL LANGUAGE MODE)
LIMIT ? OFFSET ?;
```

**按营养需求查询食谱**：
```sql
SELECT * FROM `recipe` 
WHERE `is_published` = TRUE 
  AND `calories` BETWEEN ? AND ? 
  AND (`category` = ? OR ? IS NULL)
  AND (`meal_type` = ? OR ? IS NULL)
ORDER BY ABS(`calories` - ?) ASC  -- 优先返回接近目标卡路里的食谱
LIMIT ?;
```

#### 5.3.3 膳食计划相关SQL

**添加膳食计划**：
```sql
INSERT INTO `meal_plan` 
  (`user_id`, `plan_name`, `plan_date`, `meal_type`, `recipe_id`, `custom_meal`, `calories`, `notes`) 
VALUES (?, ?, ?, ?, ?, ?, ?, ?);
```

**查询用户指定日期范围的膳食计划**：
```sql
SELECT mp.*, r.`name` AS `recipe_name`, r.`image_url` AS `recipe_image` 
FROM `meal_plan` mp 
LEFT JOIN `recipe` r ON mp.`recipe_id` = r.`id` 
WHERE mp.`user_id` = ? 
  AND mp.`plan_date` BETWEEN ? AND ? 
ORDER BY mp.`plan_date` ASC, mp.`meal_type` ASC;
```

**统计膳食计划完成情况**：
```sql
SELECT 
  DATE(`plan_date`) AS `date`,
  COUNT(*) AS `total_meals`,
  SUM(CASE WHEN `is_completed` = TRUE THEN 1 ELSE 0 END) AS `completed_meals`,
  SUM(`calories`) AS `total_calories`,
  SUM(CASE WHEN `meal_type` = '早餐' THEN `calories` ELSE 0 END) AS `breakfast_calories`,
  SUM(CASE WHEN `meal_type` = '午餐' THEN `calories` ELSE 0 END) AS `lunch_calories`,
  SUM(CASE WHEN `meal_type` = '晚餐' THEN `calories` ELSE 0 END) AS `dinner_calories`,
  SUM(CASE WHEN `meal_type` = '加餐' THEN `calories` ELSE 0 END) AS `snack_calories`
FROM `meal_plan` 
WHERE `user_id` = ? 
  AND `plan_date` BETWEEN ? AND ? 
GROUP BY DATE(`plan_date`) 
ORDER BY `date` ASC;
```

#### 5.3.4 事务管理示例

**用户健康数据更新事务**：
```sql
START TRANSACTION;

-- 更新用户健康数据
UPDATE `user` SET 
  `height` = ?, 
  `weight` = ?, 
  `bmi` = ?, 
  `physical_status` = ?, 
  `update_time` = NOW() 
WHERE `id` = ?;

-- 检查更新是否成功
IF ROW_COUNT() = 0 THEN
  ROLLBACK;
  SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户不存在或更新失败';
END IF;

-- 如果BMI发生显著变化，自动生成新的膳食计划建议
INSERT INTO `nutrition_advice` (`user_id`, `advice_type`, `advice_content`, `create_time`) 
VALUES (?, 'bmi_change', ?, NOW());

COMMIT;
```

### 5.4 数据库连接池配置

**HikariCP配置示例**：
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/health_system?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
      idle-timeout: 30000
      connection-timeout: 30000
      max-lifetime: 1800000
      validation-timeout: 5000
      leak-detection-threshold: 60000
```

**连接池参数说明**：
- `minimum-idle`: 最小空闲连接数，确保至少有5个连接随时可用
- `maximum-pool-size`: 最大连接数，根据系统负载调整
- `idle-timeout`: 空闲连接超时时间，超过此时间的空闲连接将被关闭
- `connection-timeout`: 连接获取超时时间
- `max-lifetime`: 连接最大生命周期
- `validation-timeout`: 连接有效性验证超时时间
- `leak-detection-threshold`: 连接泄漏检测阈值

## 6. API接口详细设计

### 6.1 接口设计原则

1. **RESTful设计风格**：使用标准的HTTP方法（GET、POST、PUT、DELETE）表示操作类型
2. **统一响应格式**：所有接口返回统一的JSON格式，包含状态码、消息和数据
3. **参数验证**：使用注解进行参数校验，确保数据正确性
4. **安全性**：实现JWT认证、权限控制和请求限流
5. **错误处理**：统一的异常处理机制，返回友好的错误信息

### 6.2 基础响应类设计

```java
/**
 * API响应结果类
 */
public class ApiResponse<T> {
    private int code;           // 响应状态码
    private String message;     // 响应消息
    private T data;             // 响应数据
    private long timestamp;     // 响应时间戳
    
    public ApiResponse() {
        this.timestamp = System.currentTimeMillis();
    }
    
    // 成功响应
    public static <T> ApiResponse<T> success(T data) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setCode(200);
        response.setMessage("success");
        response.setData(data);
        return response;
    }
    
    // 错误响应
    public static <T> ApiResponse<T> error(int code, String message) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setCode(code);
        response.setMessage(message);
        return response;
    }
    
    // getter和setter方法
    public int getCode() {
        return code;
    }
    
    public void setCode(int code) {
        this.code = code;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
    
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
}
```

### 6.3 自定义认证实现

#### 6.3.1 自定义认证实现

系统采用基于Session的自定义认证机制，而非JWT认证。密码使用MD5加盐加密存储，具体实现如下：

```java
/**
 * 密码加密工具方法（在UserService和AdminService中实现）
 */
private String securePass(String password) {
    // 使用MD5加盐加密
    return SecureUtil.md5(password + PASS_SALT);
}
    
    // getter和setter方法
    // ...
}
```

#### 6.3.2 登录认证实现

```java
/**
 * 登录认证方法（在UserService和AdminService中实现）
 */
public Account login(Account account) {
    // 密码加密验证
    account.setPassword(securePass(account.getPassword()));
    Account dbUser = userMapper.selectByUsername(account.getUsername());
    if (ObjectUtil.isNull(dbUser)) {
        throw new CustomException("用户不存在");
    }
    if (!account.getPassword().equals(dbUser.getPassword())) {
        throw new CustomException("账号或密码错误");
    }
    return dbUser;
}
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtConfig.getExpiration()))
                .signWith(SignatureAlgorithm.HS512, jwtConfig.getSecret())
                .compact();
    }
    
    /**
     * 生成刷新令牌
     */
    public String generateRefreshToken(Integer userId) {
        return Jwts.builder()
                .setSubject(userId.toString())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtConfig.getRefreshExpiration()))
                .signWith(SignatureAlgorithm.HS512, jwtConfig.getSecret())
                .compact();
    }
    
    /**
     * 从令牌中获取用户ID
     */
    public Integer getUserIdFromToken(String token) {
    // 系统实际不使用JWT相关功能，采用自定义认证实现
}
```

### 6.4 自定义认证机制

```java
// 系统实际使用基于Session的自定义认证机制
// 密码验证通过MD5加盐实现，在UserService和AdminService中实现
// 用户登录成功后，信息存储在Session中
// 无需专门的拦截器，通过控制器方法进行简单的权限控制
// 登录接口路径为/login，接受Account对象参数
// 返回包含用户信息的响应
```
### 6.5 API接口实现

#### 6.5.1 用户管理接口

```java
/**
 * 用户控制器
 */
@RestController
@RequestMapping("/api/user")
public class UserController extends BaseController {
    @Autowired
    private UserService userService;
    
    @Autowired
    private AuthService authService;
    
    /**
     * 用户注册
     */
    @PostMapping("/register")
    @AnonymousAccess
    public ApiResponse<Boolean> register(@Valid @RequestBody RegisterRequest request) {
        // 参数验证
        if (userService.existsByUsername(request.getUsername())) {
            throw new BusinessException("用户名已存在");
        }
        
        // 创建用户
        User user = new User();
        user.setUsername(request.getUsername());
        user.setPassword(request.getPassword());
        user.setName(request.getName());
        user.setPhone(request.getPhone());
        user.setEmail(request.getEmail());
        user.setGender(request.getGender());
        
        return ApiResponse.success(userService.add(user));
    }
    
    /**
     * 获取当前用户信息
     */
    @GetMapping("/info")
    public ApiResponse<User> getCurrentUser() {
        Integer userId = SecurityUtils.getCurrentUserId();
        User user = userService.selectById(userId);
        if (user == null) {
            throw new BusinessException("用户不存在");
        }
        // 清除敏感信息
        user.setPassword(null);
        return ApiResponse.success(user);
    }
    
    /**
     * 更新用户信息
     */
    @PutMapping("/update")
    public ApiResponse<Boolean> updateUser(@Valid @RequestBody UserUpdateRequest request) {
        Integer userId = SecurityUtils.getCurrentUserId();
        
        User user = userService.selectById(userId);
        if (user == null) {
            throw new BusinessException("用户不存在");
        }
        
        // 更新用户信息
        user.setName(request.getName());
        user.setPhone(request.getPhone());
        user.setEmail(request.getEmail());
        
        return ApiResponse.success(userService.updateById(user));
    }
    
    /**
     * 更新用户健康数据
     */
    @PutMapping("/health-data")
    public ApiResponse<Boolean> updateHealthData(@Valid @RequestBody HealthDataRequest request) {
        Integer userId = SecurityUtils.getCurrentUserId();
        
        Map<String, Object> healthData = new HashMap<>();
        healthData.put("height", request.getHeight());
        healthData.put("weight", request.getWeight());
        healthData.put("age", request.getAge());
        healthData.put("gender", request.getGender());
        healthData.put("activityLevel", request.getActivityLevel());
        healthData.put("goal", request.getGoal());
        
        return ApiResponse.success(userService.updateHealthData(userId, healthData));
    }
    
    /**
     * 重置密码
     */
    @PutMapping("/reset-password")
    public ApiResponse<Boolean> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
        Integer userId = SecurityUtils.getCurrentUserId();
        return ApiResponse.success(userService.resetPassword(userId, request.getOldPassword(), request.getNewPassword()));
    }
}
```

#### 6.5.2 认证管理接口

```java
/**
 * 认证控制器
 */
@RestController
@RequestMapping("/api/auth")
public class AuthController extends BaseController {
    @Autowired
    private AuthService authService;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private RecipeCacheService cacheService;
    
    /**
     * 用户登录
     */
    @PostMapping("/login")
    @AnonymousAccess
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        // 验证码校验
        validateCaptcha(request.getCaptcha(), request.getCaptchaKey());
        
        // 登录认证
        LoginResponse loginResponse = authService.login(request.getUsername(), request.getPassword());
        
        // 更新登录信息
        User user = authService.getUserByUsername(request.getUsername());
        userService.updateLoginInfo(user.getId(), true);
        
        return ApiResponse.success(loginResponse);
    }
    
    /**
     * 刷新令牌
     */
    @PostMapping("/refresh")
    public ApiResponse<LoginResponse> refreshToken(@RequestBody RefreshTokenRequest request) {
        LoginResponse loginResponse = authService.refreshToken(request.getRefreshToken());
        return ApiResponse.success(loginResponse);
    }
    
    /**
     * 退出登录
     */
    @PostMapping("/logout")
    public ApiResponse<Boolean> logout() {
        // 清除缓存中的Token信息
        return ApiResponse.success(true);
    }
    
    /**
     * 获取验证码
     */
    @GetMapping("/captcha")
    @AnonymousAccess
    public void getCaptcha(HttpServletResponse response) throws IOException {
        // 生成验证码
        Captcha captcha = CaptchaUtil.createShearCaptcha(150, 40, 4, 4);
        String captchaCode = captcha.getCode();
        
        // 生成验证码key
        String captchaKey = UUID.randomUUID().toString();
        
        // 将验证码存入缓存，设置过期时间5分钟
        cacheService.set("captcha:" + captchaKey, captchaCode, 5, TimeUnit.MINUTES);
        
        // 设置响应头
        response.setHeader("captcha-key", captchaKey);
        response.setContentType("image/png");
        
        // 输出验证码图片
        captcha.write(response.getOutputStream());
    }
    
    @Autowired
    private RecipeCacheService cacheService;
    
    /**
     * 验证码校验
     */
    private void validateCaptcha(String captcha, String captchaKey) {
        if (StringUtils.isEmpty(captcha) || StringUtils.isEmpty(captchaKey)) {
            throw new BusinessException("验证码不能为空");
        }
        
        // 从缓存获取验证码
        String cachedCaptcha = cacheService.get("captcha:" + captchaKey, String.class);
        if (StringUtils.isEmpty(cachedCaptcha)) {
            throw new BusinessException("验证码已过期");
        }
        
        // 验证码校验
        if (!captcha.equalsIgnoreCase(cachedCaptcha)) {
            throw new BusinessException("验证码错误");
        }
        
        // 校验通过后删除验证码
        cacheService.delete("captcha:" + captchaKey);
    }
}
```

#### 6.5.3 食谱管理接口

```java
/**
 * 食谱控制器
 */
@RestController
@RequestMapping("/api/recipe")
public class RecipeController extends BaseController {
    @Autowired
    private RecipeService recipeService;
    
    /**
     * 获取食谱详情
     */
    @GetMapping("/{id}")
    public ApiResponse<Recipe> getRecipeById(@PathVariable Integer id) {
        Recipe recipe = recipeService.selectById(id);
        if (recipe == null) {
            throw new BusinessException("食谱不存在");
        }
        return ApiResponse.success(recipe);
    }
    
    /**
     * 分页查询食谱列表
     */
    @GetMapping("/list")
    public ApiResponse<PageInfo<Recipe>> getRecipeList(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String mealType,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        Recipe recipe = new Recipe();
        recipe.setCategory(category);
        recipe.setMealType(mealType);
        recipe.setIsPublished(true);
        
        return ApiResponse.success(recipeService.selectPage(recipe, pageNum, pageSize));
    }
    
    /**
     * 搜索食谱
     */
    @GetMapping("/search")
    public ApiResponse<PageInfo<Recipe>> searchRecipes(
            @RequestParam String keyword,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        return ApiResponse.success(recipeService.search(keyword, pageNum, pageSize));
    }
    
    /**
     * 获取热门食谱
     */
    @GetMapping("/popular")
    public ApiResponse<List<Recipe>> getPopularRecipes(@RequestParam(defaultValue = "10") Integer limit) {
        return ApiResponse.success(recipeService.getPopularRecipes(limit));
    }
    
    /**
     * 根据营养需求推荐食谱
     */
    @PostMapping("/recommend")
    public ApiResponse<List<Recipe>> recommendRecipes(
            @Valid @RequestBody RecipeRecommendRequest request) {
        
        Map<String, Integer> calorieRange = new HashMap<>();
        calorieRange.put("min", request.getMinCalories());
        calorieRange.put("max", request.getMaxCalories());
        
        return ApiResponse.success(recipeService.recommendByNutrition(
                calorieRange, request.getCategory(), request.getLimit()));
    }
    
    /**
     * 添加食谱（管理员）
     */
    @PostMapping("/")
    @PreAuthorize("hasRole('ADMIN')")
    public ApiResponse<Boolean> addRecipe(@Valid @RequestBody RecipeRequest request) {
        Recipe recipe = new Recipe();
        recipe.setName(request.getName());
        recipe.setDescription(request.getDescription());
        recipe.setIngredients(JSON.toJSONString(request.getIngredients()));
        recipe.setInstructions(JSON.toJSONString(request.getInstructions()));
        recipe.setCookingTime(request.getCookingTime());
        recipe.setPreparationTime(request.getPreparationTime());
        recipe.setServings(request.getServings());
        recipe.setCalories(request.getCalories());
        recipe.setProtein(request.getProtein());
        recipe.setCarbs(request.getCarbs());
        recipe.setFat(request.getFat());
        recipe.setFiber(request.getFiber());
        recipe.setCategory(request.getCategory());
        recipe.setMealType(request.getMealType());
        recipe.setImageUrl(request.getImageUrl());
        
        return ApiResponse.success(recipeService.add(recipe));
    }
    
    /**
     * 更新食谱（管理员）
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ApiResponse<Boolean> updateRecipe(
            @PathVariable Integer id, 
            @Valid @RequestBody RecipeRequest request) {
        
        Recipe recipe = recipeService.selectById(id);
        if (recipe == null) {
            throw new BusinessException("食谱不存在");
        }
        
        recipe.setName(request.getName());
        recipe.setDescription(request.getDescription());
        recipe.setIngredients(JSON.toJSONString(request.getIngredients()));
        recipe.setInstructions(JSON.toJSONString(request.getInstructions()));
        recipe.setCookingTime(request.getCookingTime());
        recipe.setPreparationTime(request.getPreparationTime());
        recipe.setServings(request.getServings());
        recipe.setCalories(request.getCalories());
        recipe.setProtein(request.getProtein());
        recipe.setCarbs(request.getCarbs());
        recipe.setFat(request.getFat());
        recipe.setFiber(request.getFiber());
        recipe.setCategory(request.getCategory());
        recipe.setMealType(request.getMealType());
        recipe.setImageUrl(request.getImageUrl());
        
        return ApiResponse.success(recipeService.updateById(recipe));
    }
    
    /**
     * 删除食谱（管理员）
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ApiResponse<Boolean> deleteRecipe(@PathVariable Integer id) {
        return ApiResponse.success(recipeService.deleteById(id));
    }
}
```

#### 6.5.4 膳食计划管理接口

```java
/**
 * 膳食计划控制器
 */
@RestController
@RequestMapping("/api/meal-plan")
public class MealPlanController extends BaseController {
    @Autowired
    private MealPlanService mealPlanService;
    
    @Autowired
    private NutritionAnalysisService nutritionAnalysisService;
    
    /**
     * 获取用户的膳食计划列表
     */
    @GetMapping("/list")
    public ApiResponse<List<MealPlan>> getMealPlans(
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        
        if (startDate != null && endDate != null) {
            return ApiResponse.success(mealPlanService.selectByDateRange(userId, startDate, endDate));
        } else {
            return ApiResponse.success(mealPlanService.selectByUserId(userId));
        }
    }
    
    /**
     * 添加膳食计划
     */
    @PostMapping("/")
    public ApiResponse<Boolean> addMealPlan(@Valid @RequestBody MealPlanRequest request) {
        Integer userId = SecurityUtils.getCurrentUserId();
        
        // 检查是否已有相同日期和餐次的计划
        if (mealPlanService.hasPlan(userId, request.getPlanDate(), request.getMealType())) {
            throw new BusinessException("该日期和餐次已存在膳食计划");
        }
        
        MealPlan mealPlan = new MealPlan();
        mealPlan.setUserId(userId);
        mealPlan.setPlanName(request.getPlanName());
        mealPlan.setPlanDate(request.getPlanDate());
        mealPlan.setMealType(request.getMealType());
        mealPlan.setRecipeId(request.getRecipeId());
        mealPlan.setCustomMeal(request.getCustomMeal());
        mealPlan.setCalories(request.getCalories());
        mealPlan.setNotes(request.getNotes());
        
        return ApiResponse.success(mealPlanService.add(mealPlan));
    }
    
    /**
     * 更新膳食计划
     */
    @PutMapping("/{id}")
    public ApiResponse<Boolean> updateMealPlan(
            @PathVariable Integer id, 
            @Valid @RequestBody MealPlanRequest request) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        MealPlan mealPlan = mealPlanService.selectById(id);
        
        if (mealPlan == null) {
            throw new BusinessException("膳食计划不存在");
        }
        
        // 验证权限
        if (!userId.equals(mealPlan.getUserId())) {
            throw new BusinessException("无权操作此膳食计划");
        }
        
        // 更新膳食计划
        mealPlan.setPlanName(request.getPlanName());
        mealPlan.setRecipeId(request.getRecipeId());
        mealPlan.setCustomMeal(request.getCustomMeal());
        mealPlan.setCalories(request.getCalories());
        mealPlan.setNotes(request.getNotes());
        
        return ApiResponse.success(mealPlanService.updateById(mealPlan));
    }
    
    /**
     * 删除膳食计划
     */
    @DeleteMapping("/{id}")
    public ApiResponse<Boolean> deleteMealPlan(@PathVariable Integer id) {
        Integer userId = SecurityUtils.getCurrentUserId();
        MealPlan mealPlan = mealPlanService.selectById(id);
        
        if (mealPlan == null) {
            throw new BusinessException("膳食计划不存在");
        }
        
        // 验证权限
        if (!userId.equals(mealPlan.getUserId())) {
            throw new BusinessException("无权操作此膳食计划");
        }
        
        return ApiResponse.success(mealPlanService.deleteById(id));
    }
    
    /**
     * 标记膳食计划完成状态
     */
    @PutMapping("/{id}/status")
    public ApiResponse<Boolean> markMealPlanStatus(
            @PathVariable Integer id, 
            @RequestBody @Valid StatusRequest request) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        MealPlan mealPlan = mealPlanService.selectById(id);
        
        if (mealPlan == null) {
            throw new BusinessException("膳食计划不存在");
        }
        
        // 验证权限
        if (!userId.equals(mealPlan.getUserId())) {
            throw new BusinessException("无权操作此膳食计划");
        }
        
        return ApiResponse.success(mealPlanService.markAsCompleted(id, request.getCompleted()));
    }
    
    /**
     * 获取膳食计划统计数据
     */
    @GetMapping("/statistics")
    public ApiResponse<Map<String, Object>> getStatistics(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        return ApiResponse.success(mealPlanService.getDailyStatistics(userId, startDate, endDate));
    }
    
    /**
     * 生成膳食计划
     */
    @PostMapping("/generate")
    public ApiResponse<List<MealPlan>> generateMealPlan(
            @Valid @RequestBody GenerateMealPlanRequest request) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        User user = userService.selectById(userId);
        
        if (user == null) {
            throw new BusinessException("用户不存在");
        }
        
        // 生成膳食计划
        List<MealPlan> mealPlans = nutritionAnalysisService.generateMealPlan(
                user, request.getStartDate(), request.getDays());
        
        return ApiResponse.success(mealPlans);
    }
}
```

#### 6.5.5 营养分析管理接口

```java
/**
 * 营养分析控制器
 */
@RestController
@RequestMapping("/api/nutrition")
public class NutritionAnalysisController extends BaseController {
    @Autowired
    private NutritionAnalysisService nutritionAnalysisService;
    
    /**
     * 获取用户的营养计划
     */
    @GetMapping("/plan")
    public ApiResponse<NutritionPlanResponse> getNutritionPlan() {
        Integer userId = SecurityUtils.getCurrentUserId();
        return ApiResponse.success(nutritionAnalysisService.calculateNutritionPlanById(userId));
    }
    
    /**
     * 计算BMI
     */
    @PostMapping("/bmi")
    public ApiResponse<Double> calculateBMI(@Valid @RequestBody BMICalculationRequest request) {
        Double bmi = nutritionAnalysisService.calculateBMI(request.getHeight(), request.getWeight());
        if (bmi == null) {
            throw new BusinessException("BMI计算参数无效");
        }
        return ApiResponse.success(bmi);
    }
    
    /**
     * 根据营养需求推荐食谱
     */
    @GetMapping("/recommend-recipes")
    public ApiResponse<List<Recipe>> recommendRecipesByNutrition(
            @RequestParam String mealType,
            @RequestParam(defaultValue = "5") Integer limit) {
        
        Integer userId = SecurityUtils.getCurrentUserId();
        User user = userService.selectById(userId);
        
        if (user == null) {
            throw new BusinessException("用户不存在");
        }
        
        return ApiResponse.success(nutritionAnalysisService.recommendRecipes(user, mealType, limit));
    }
}
```

### 6.6 请求DTO类设计

#### 6.6.1 用户相关DTO

```java
/**
 * 用户更新请求DTO
 */
@Data
public class UserUpdateRequest {
    @NotBlank(message = "姓名不能为空")
    private String name;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Pattern(regexp = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$", message = "邮箱格式不正确")
    private String email;
}

/**
 * 健康数据请求DTO
 */
@Data
public class HealthDataRequest {
    @NotNull(message = "身高不能为空")
    @Min(value = 50, message = "身高不能小于50cm")
    @Max(value = 250, message = "身高不能大于250cm")
    private Double height;
    
    @NotNull(message = "体重不能为空")
    @Min(value = 10, message = "体重不能小于10kg")
    @Max(value = 500, message = "体重不能大于500kg")
    private Double weight;
    
    @NotNull(message = "年龄不能为空")
    @Min(value = 1, message = "年龄不能小于1岁")
    @Max(value = 150, message = "年龄不能大于150岁")
    private Integer age;
    
    @NotNull(message = "性别不能为空")
    private String gender;
    
    @NotNull(message = "活动水平不能为空")
    private String activityLevel;
    
    @NotNull(message = "健康目标不能为空")
    private String goal;
}

/**
 * 重置密码请求DTO
 */
@Data
public class ResetPasswordRequest {
    @NotBlank(message = "旧密码不能为空")
    private String oldPassword;
    
    @NotBlank(message = "新密码不能为空")
    @Size(min = 6, max = 20, message = "新密码长度必须在6-20个字符之间")
    private String newPassword;
}
```

#### 6.6.2 食谱相关DTO

```java
/**
 * 食谱请求DTO
 */
@Data
public class RecipeRequest {
    @NotBlank(message = "食谱名称不能为空")
    private String name;
    
    private String description;
    
    @NotNull(message = "食材列表不能为空")
    private List<Ingredient> ingredients;
    
    @NotNull(message = "制作步骤不能为空")
    private List<Instruction> instructions;
    
    private Integer cookingTime;
    
    private Integer preparationTime;
    
    private Integer servings;
    
    @NotNull(message = "卡路里不能为空")
    @Min(value = 0, message = "卡路里不能为负数")
    private Integer calories;
    
    @Min(value = 0, message = "蛋白质不能为负数")
    private Double protein;
    
    @Min(value = 0, message = "碳水化合物不能为负数")
    private Double carbs;
    
    @Min(value = 0, message = "脂肪不能为负数")
    private Double fat;
    
    @Min(value = 0, message = "膳食纤维不能为负数")
    private Double fiber;
    
    @NotBlank(message = "分类不能为空")
    private String category;
    
    private String mealType;
    
    private String imageUrl;
}

/**
 * 食材DTO
 */
@Data
public class Ingredient {
    @NotBlank(message = "食材名称不能为空")
    private String name;
    
    @NotBlank(message = "食材用量不能为空")
    private String amount;
    
    private String unit;
}

/**
 * 制作步骤DTO
 */
@Data
public class Instruction {
    private Integer stepNumber;
    
    @NotBlank(message = "步骤描述不能为空")
    private String description;
}

/**
 * 食谱推荐请求DTO
 */
@Data
public class RecipeRecommendRequest {
    @NotNull(message = "最小卡路里不能为空")
    @Min(value = 0, message = "最小卡路里不能为负数")
    private Integer minCalories;
    
    @NotNull(message = "最大卡路里不能为空")
    @Min(value = 1, message = "最大卡路里不能小于1")
    private Integer maxCalories;
    
    private String category;
    
    @NotNull(message = "推荐数量不能为空")
    @Min(value = 1, message = "推荐数量不能小于1")
    @Max(value = 50, message = "推荐数量不能大于50")
    private Integer limit;
}
```

#### 6.6.3 膳食计划相关DTO

```java
/**
 * 膳食计划请求DTO
 */
@Data
public class MealPlanRequest {
    @NotBlank(message = "计划名称不能为空")
    private String planName;
    
    @NotNull(message = "计划日期不能为空")
    private LocalDate planDate;
    
    @NotBlank(message = "餐次类型不能为空")
    private String mealType;
    
    private Integer recipeId;
    
    private String customMeal;
    
    @Min(value = 0, message = "卡路里不能为负数")
    private Integer calories;
    
    private String notes;
}

/**
 * 状态更新请求DTO
 */
@Data
public class StatusRequest {
    @NotNull(message = "完成状态不能为空")
    private Boolean completed;
}

/**
 * 生成膳食计划请求DTO
 */
@Data
public class GenerateMealPlanRequest {
    @NotNull(message = "开始日期不能为空")
    private LocalDate startDate;
    
    @NotNull(message = "天数不能为空")
    @Min(value = 1, message = "天数不能小于1")
    @Max(value = 30, message = "天数不能大于30")
    private Integer days;
}
```

#### 6.6.4 营养分析相关DTO

```java
/**
 * BMI计算请求DTO
 */
@Data
public class BMICalculationRequest {
    @NotNull(message = "身高不能为空")
    @Min(value = 50, message = "身高不能小于50cm")
    @Max(value = 250, message = "身高不能大于250cm")
    private Double height;
    
    @NotNull(message = "体重不能为空")
    @Min(value = 10, message = "体重不能小于10kg")
    @Max(value = 500, message = "体重不能大于500kg")
    private Double weight;
}
```

### 6.7 参数验证规则

#### 6.7.1 全局异常处理

```java
/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    /**
     * 处理业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public ApiResponse<?> handleBusinessException(BusinessException e) {
        logger.error("业务异常: {}", e.getMessage());
        return ApiResponse.error(e.getCode(), e.getMessage());
    }
    
    /**
     * 处理参数验证异常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ApiResponse<?> handleValidationException(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        StringBuilder errorMessage = new StringBuilder();
        
        if (bindingResult.hasErrors()) {
            List<ObjectError> errors = bindingResult.getAllErrors();
            for (ObjectError error : errors) {
                if (error instanceof FieldError) {
                    errorMessage.append(((FieldError) error).getField()).append(": ");
                }
                errorMessage.append(error.getDefaultMessage()).append("; ");
            }
        }
        
        logger.error("参数验证异常: {}", errorMessage.toString());
        return ApiResponse.error(400, errorMessage.toString());
    }
    
    /**
     * 处理空指针异常
     */
    @ExceptionHandler(NullPointerException.class)
    public ApiResponse<?> handleNullPointerException(NullPointerException e) {
        logger.error("空指针异常: {}", e.getMessage(), e);
        return ApiResponse.error(500, "服务器内部错误");
    }
    
    /**
     * 处理SQL异常
     */
    @ExceptionHandler(SQLException.class)
    public ApiResponse<?> handleSQLException(SQLException e) {
        logger.error("数据库异常: {}", e.getMessage(), e);
        return ApiResponse.error(500, "数据库操作失败");
    }
    
    /**
     * 处理未知异常
     */
    @ExceptionHandler(Exception.class)
    public ApiResponse<?> handleUnknownException(Exception e) {
        logger.error("未知异常: {}", e.getMessage(), e);
        return ApiResponse.error(500, "服务器内部错误");
    }
}
```

#### 6.7.2 自定义业务异常类

```java
/**
 * 业务异常类
 */
public class BusinessException extends RuntimeException {
    private int code = 400;
    
    public BusinessException(String message) {
        super(message);
    }
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
    
    public int getCode() {
        return code;
    }
    
    public void setCode(int code) {
        this.code = code;
    }
}
```

### 6.8 日志和安全设计

```java
/**
 * 请求日志拦截器
 */
@Component
public class RequestLoggingInterceptor implements HandlerInterceptor {
    private static final Logger logger = LoggerFactory.getLogger(RequestLoggingInterceptor.class);
    
    private ThreadLocal<Long> startTimeThreadLocal = new ThreadLocal<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 记录请求开始时间
        startTimeThreadLocal.set(System.currentTimeMillis());
        
        // 记录请求信息（不记录敏感信息）
        String url = request.getRequestURL().toString();
        String method = request.getMethod();
        String clientIp = getClientIp(request);
        
        logger.info("请求开始 - URL: {}, 方法: {}, IP: {}", url, method, clientIp);
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 记录请求结束时间
        long startTime = startTimeThreadLocal.get();
        long endTime = System.currentTimeMillis();
        long executeTime = endTime - startTime;
        
        // 记录请求结果
        String url = request.getRequestURL().toString();
        int status = response.getStatus();
        
        if (ex != null) {
            logger.error("请求异常 - URL: {}, 状态码: {}, 执行时间: {}ms, 异常: {}", 
                    url, status, executeTime, ex.getMessage());
        } else {
            logger.info("请求结束 - URL: {}, 状态码: {}, 执行时间: {}ms", url, status, executeTime);
        }
        
        // 清除ThreadLocal
        startTimeThreadLocal.remove();
    }
    
    /**
     * 获取客户端真实IP
     */
    private String getClientIp(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        
        // 多级代理的情况，取第一个IP
        if (ip != null && ip.contains(",")) {
            ip = ip.split(",")[0].trim();
        }
        
        return ip;
    }
}
```

### 6.9 限流配置

```java
/**
 * 限流注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimiter {
    /**
     * 限流类型
     */
    LimitType limitType() default LimitType.DEFAULT;
    
    /**
     * 每秒允许的请求数
     */
    double value() default 10;
    
    /**
     * 超时时间（毫秒）
     */
    long timeout() default 0;
}

/**
 * 限流类型枚举
 */
public enum LimitType {
    /**
     * 默认限流策略，针对每个请求
     */
    DEFAULT,
    
    /**
     * 针对IP限流
     */
    IP,
    
    /**
     * 针对用户限流
     */
    USER
}

/**
 * 限流AOP实现
 * 使用本地内存缓存实现限流功能
 */
@Aspect
@Component
public class RateLimiterAspect {
    // 使用本地内存ConcurrentHashMap实现限流计数
    private final ConcurrentHashMap<String, LinkedList<Long>> requestCounts = new ConcurrentHashMap<>();
    
    @Pointcut("@annotation(com.health.system.annotation.RateLimiter)")
    public void rateLimiterPointCut() {}
    
    @Around("rateLimiterPointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        HttpServletRequest request = RequestContextHolder.currentRequestAttributes().getRequest();
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        
        // 获取限流注解
        RateLimiter rateLimiter = method.getAnnotation(RateLimiter.class);
        
        // 构建限流键
        String key = generateKey(request, rateLimiter);
        
        // 使用本地内存实现限流逻辑
        long currentTime = System.currentTimeMillis();
        int limit = rateLimiter.value();
        int timeout = rateLimiter.timeout() * 1000; // 转换为毫秒
        
        // 获取或创建请求计数列表
        requestCounts.putIfAbsent(key, new LinkedList<>());
        LinkedList<Long> timestamps = requestCounts.get(key);
        
        synchronized (timestamps) {
            // 移除过期的请求时间戳
            while (!timestamps.isEmpty() && currentTime - timestamps.getFirst() > timeout) {
                timestamps.removeFirst();
            }
            
            // 检查是否超过限制
            if (timestamps.size() < limit) {
                // 未超过限制，记录当前请求
                timestamps.addLast(currentTime);
                // 继续执行
                return point.proceed();
            } else {
                // 超过限制，抛出异常
                throw new BusinessException(429, "请求过于频繁，请稍后再试");
            }
        }
    }
    
    /**
     * 生成限流键
     */
    private String generateKey(HttpServletRequest request, RateLimiter rateLimiter) {
        StringBuilder key = new StringBuilder("rate_limit:");
        
        // 根据限流类型生成不同的键
        switch (rateLimiter.limitType()) {
            case IP:
                key.append("ip:")
                   .append(getClientIp(request));
                break;
            case USER:
                try {
                    Integer userId = SecurityUtils.getCurrentUserId();
                    key.append("user:")
                       .append(userId != null ? userId : "anonymous");
                } catch (Exception e) {
                    key.append("user:anonymous");
                }
                break;
            default:
                // 默认使用请求URI
                key.append("uri:")
                   .append(request.getRequestURI());
                break;
        }
        
        return key.toString();
    }
    
    /**
     * 获取客户端IP
     */
    private String getClientIp(HttpServletRequest request) {
        // 实现方法与之前相同
        // ...
    }
}
```

### 6.10 接口文档配置

```java
/**
 * Swagger配置类
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.health.system.controller"))
                .paths(PathSelectors.any())
                .build()
                .securitySchemes(Collections.singletonList(apiKey()))
                .securityContexts(Collections.singletonList(securityContext()));
    }
    
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("健康饮食系统API文档")
                .description("健康饮食系统的API接口文档")
                .version("1.0.0")
                .build();
    }
    
    private ApiKey apiKey() {
        return new ApiKey("JWT", "Authorization", "header");
    }
    
    private SecurityContext securityContext() {
        return SecurityContext.builder()
                .securityReferences(defaultAuth())
                .forPaths(PathSelectors.any())
                .build();
    }
    
    private List<SecurityReference> defaultAuth() {
        AuthorizationScope authorizationScope = new AuthorizationScope("global", "accessEverything");
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        return Collections.singletonList(new SecurityReference("JWT", authorizationScopes));
    }
}
```

## 7. 前端技术栈与架构设计

### 7.1 技术栈选择

| 技术/框架 | 版本 | 用途 | 选型理由 |
| :--- | :--- | :--- | :--- |
| Vue | 3.x | 前端框架 | 轻量级、响应式、易上手、生态成熟 |
| TypeScript | 4.x | 开发语言 | 强类型系统，提升代码质量和开发效率 |
| Vite | 4.x | 构建工具 | 极速的开发体验，快速的HMR和构建性能 |
| Element Plus | 2.x | UI组件库 | 基于Vue 3，组件丰富，文档完善，活跃维护 |
| Pinia | 2.x | 状态管理 | Vue官方推荐，TypeScript支持好，轻量简洁 |
| Vue Router | 4.x | 路由管理 | 与Vue 3完美配合，支持组合式API |
| Axios | 1.x | HTTP客户端 | 拦截器丰富，功能完善，生态成熟 |
| ECharts | 5.x | 图表展示 | 丰富的图表类型，高性能，交互友好 |
| SCSS | 最新 | CSS预处理器 | 增强CSS功能，提高开发效率 |
| Vitest | 0.30+ | 单元测试 | 与Vite集成，极速测试体验 |

### 7.2 前端架构设计

#### 7.2.1 整体架构

```
前端架构 ── 采用前后端分离架构
    │
    ├── 表现层（UI） ── Vue 3 + Element Plus组件
    │
    ├── 应用层（业务逻辑） ── 组合式API、自定义Hooks
    │
    ├── 数据层
    │   ├── 状态管理 ── Pinia
    │   ├── 数据持久化 ── localStorage/sessionStorage
    │   └── 网络请求 ── Axios
    │
    └── 工具层
        ├── 公共组件
        ├── 工具函数
        ├── 样式主题
        └── 路由守卫
```

#### 7.2.2 目录结构

```
/src
  /assets          # 静态资源
    /images        # 图片资源
    /icons         # 图标资源
    /styles        # 全局样式
  /components      # 公共组件
    /base          # 基础组件
    /business      # 业务组件
    /layout        # 布局组件
  /composables     # 组合式API
    /hooks         # 自定义Hooks
  /directives      # 自定义指令
  /plugins         # 插件配置
  /router          # 路由配置
    /modules       # 路由模块
  /store           # 状态管理（Pinia）
    /modules       # 状态模块
  /utils           # 工具函数
    /request       # 请求封装
    /auth          # 认证相关
    /storage       # 存储相关
    /validate      # 验证工具
  /views           # 页面视图
    /auth          # 认证相关页面
    /user          # 用户相关页面
    /recipe        # 食谱相关页面
    /meal-plan     # 膳食计划页面
    /nutrition     # 营养分析页面
    /admin         # 管理员页面
  /api             # API接口定义
  App.vue          # 根组件
  main.ts          # 入口文件
  vite-env.d.ts    # 类型声明
```

#### 7.2.3 核心模块设计

##### 7.2.3.1 路由配置

```typescript
/**
 * 路由配置
 */
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import Layout from '@/components/layout/index.vue';
import { useUserStore } from '@/store/modules/user';

// 静态路由
const constantRoutes: RouteRecordRaw[] = [
  {
    path: '/login',
    component: () => import('@/views/auth/login.vue'),
    meta: { hidden: true }
  },
  {
    path: '/register',
    component: () => import('@/views/auth/register.vue'),
    meta: { hidden: true }
  },
  {
    path: '/404',
    component: () => import('@/views/error/404.vue'),
    meta: { hidden: true }
  }
];

// 动态路由
const asyncRoutes: RouteRecordRaw[] = [
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: '仪表盘',
          icon: 'home',
          roles: ['admin', 'user']
        }
      }
    ]
  },
  {
    path: '/user',
    component: Layout,
    redirect: '/user/profile',
    meta: {
      title: '用户管理',
      icon: 'user',
      roles: ['admin', 'user']
    },
    children: [
      {
        path: 'profile',
        name: 'UserProfile',
        component: () => import('@/views/user/profile.vue'),
        meta: {
          title: '个人信息',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'health-data',
        name: 'HealthData',
        component: () => import('@/views/user/health-data.vue'),
        meta: {
          title: '健康数据',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'list',
        name: 'UserList',
        component: () => import('@/views/user/list.vue'),
        meta: {
          title: '用户列表',
          roles: ['admin']
        }
      }
    ]
  },
  {
    path: '/recipe',
    component: Layout,
    redirect: '/recipe/list',
    meta: {
      title: '食谱管理',
      icon: 'book',
      roles: ['admin', 'user']
    },
    children: [
      {
        path: 'list',
        name: 'RecipeList',
        component: () => import('@/views/recipe/list.vue'),
        meta: {
          title: '食谱列表',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'detail/:id',
        name: 'RecipeDetail',
        component: () => import('@/views/recipe/detail.vue'),
        meta: {
          title: '食谱详情',
          hidden: true,
          roles: ['admin', 'user']
        }
      },
      {
        path: 'add',
        name: 'AddRecipe',
        component: () => import('@/views/recipe/add.vue'),
        meta: {
          title: '添加食谱',
          roles: ['admin']
        }
      },
      {
        path: 'edit/:id',
        name: 'EditRecipe',
        component: () => import('@/views/recipe/edit.vue'),
        meta: {
          title: '编辑食谱',
          hidden: true,
          roles: ['admin']
        }
      }
    ]
  },
  {
    path: '/meal-plan',
    component: Layout,
    redirect: '/meal-plan/list',
    meta: {
      title: '膳食计划',
      icon: 'calendar',
      roles: ['admin', 'user']
    },
    children: [
      {
        path: 'list',
        name: 'MealPlanList',
        component: () => import('@/views/meal-plan/list.vue'),
        meta: {
          title: '计划列表',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'add',
        name: 'AddMealPlan',
        component: () => import('@/views/meal-plan/add.vue'),
        meta: {
          title: '添加计划',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'statistics',
        name: 'MealPlanStatistics',
        component: () => import('@/views/meal-plan/statistics.vue'),
        meta: {
          title: '计划统计',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'generate',
        name: 'GenerateMealPlan',
        component: () => import('@/views/meal-plan/generate.vue'),
        meta: {
          title: '生成计划',
          roles: ['admin', 'user']
        }
      }
    ]
  },
  {
    path: '/nutrition',
    component: Layout,
    redirect: '/nutrition/analysis',
    meta: {
      title: '营养分析',
      icon: 'pie-chart',
      roles: ['admin', 'user']
    },
    children: [
      {
        path: 'analysis',
        name: 'NutritionAnalysis',
        component: () => import('@/views/nutrition/analysis.vue'),
        meta: {
          title: '营养分析',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'bmi-calculator',
        name: 'BMICalculator',
        component: () => import('@/views/nutrition/bmi-calculator.vue'),
        meta: {
          title: 'BMI计算器',
          roles: ['admin', 'user']
        }
      },
      {
        path: 'nutrition-plan',
        name: 'NutritionPlan',
        component: () => import('@/views/nutrition/nutrition-plan.vue'),
        meta: {
          title: '营养计划',
          roles: ['admin', 'user']
        }
      }
    ]
  },
  {
    path: '/admin',
    component: Layout,
    redirect: '/admin/index',
    meta: {
      title: '系统管理',
      icon: 'setting',
      roles: ['admin']
    },
    children: [
      {
        path: 'index',
        name: 'AdminDashboard',
        component: () => import('@/views/admin/index.vue'),
        meta: {
          title: '管理首页',
          roles: ['admin']
        }
      },
      {
        path: 'log',
        name: 'SystemLog',
        component: () => import('@/views/admin/log.vue'),
        meta: {
          title: '系统日志',
          roles: ['admin']
        }
      }
    ]
  },
  // 404页面
  { path: '/:pathMatch(.*)*', redirect: '/404', meta: { hidden: true } }
];

const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes
});

// 路由守卫
router.beforeEach(async (to, from, next) => {
  // 获取用户存储
  const userStore = useUserStore();
  
  // 设置页面标题
  document.title = `${to.meta.title || '健康饮食系统'} - 健康饮食系统`;
  
  // 检查是否登录
  const token = userStore.token;
  
  // 如果没有token，只能访问登录和注册页面
  if (!token) {
    if (to.path === '/login' || to.path === '/register') {
      return next();
    }
    return next('/login');
  }
  
  // 有token，检查是否获取了用户信息
  if (!userStore.userInfo) {
    try {
      // 获取用户信息
      await userStore.getUserInfo();
      // 动态添加路由
      const accessRoutes = await generateRoutes(userStore.roles);
      accessRoutes.forEach(route => {
        router.addRoute(route);
      });
      // 确保路由已添加完成
      return next({ ...to, replace: true });
    } catch (error) {
      // 清除token并跳转登录
      userStore.logout();
      return next('/login');
    }
  }
  
  // 检查权限
  if (to.meta.roles && !to.meta.roles.includes(userStore.roles[0])) {
    return next('/404');
  }
  
  next();
});

// 根据角色生成可访问的路由
const generateRoutes = async (roles: string[]): Promise<RouteRecordRaw[]> => {
  const accessedRoutes: RouteRecordRaw[] = [];
  
  // 检查每个路由的权限
  asyncRoutes.forEach(route => {
    if (hasPermission(roles, route)) {
      if (route.children && route.children.length) {
        route.children = route.children.filter(child => {
          return hasPermission(roles, child);
        });
      }
      accessedRoutes.push(route);
    }
  });
  
  return accessedRoutes;
};

// 检查是否有权限
const hasPermission = (roles: string[], route: RouteRecordRaw): boolean => {
  if (route.meta && route.meta.roles) {
    return roles.some(role => route.meta!.roles!.includes(role));
  }
  return true;
};

export default router;
```

##### 7.2.3.2 状态管理

```typescript
/**
 * 用户状态管理
 */
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { UserInfo } from '@/types/user';
import { login, logout, getInfo } from '@/api/auth';
import { setToken, removeToken, getToken } from '@/utils/auth';

export const useUserStore = defineStore('user', () => {
  // 状态
  const token = ref<string>(getToken() || '');
  const userInfo = ref<UserInfo | null>(null);
  const roles = ref<string[]>([]);
  
  // 计算属性
  const isLoggedIn = computed(() => !!token.value);
  
  // 操作
  const setTokenValue = (value: string) => {
    token.value = value;
    setToken(value);
  };
  
  const clearToken = () => {
    token.value = '';
    removeToken();
  };
  
  // 登录
  const doLogin = async (username: string, password: string) => {
    const result = await login({ username, password });
    const { accessToken } = result.data;
    setTokenValue(accessToken);
    return result;
  };
  
  // 获取用户信息
  const getUserInfo = async () => {
    const result = await getInfo();
    userInfo.value = result.data;
    roles.value = result.data.roles || [];
    return result.data;
  };
  
  // 退出登录
  const logoutUser = async () => {
    await logout();
    clearToken();
    userInfo.value = null;
    roles.value = [];
  };
  
  return {
    token,
    userInfo,
    roles,
    isLoggedIn,
    setToken: setTokenValue,
    clearToken,
    login: doLogin,
    getUserInfo,
    logout: logoutUser
  };
});
```

##### 7.2.3.3 请求封装

```typescript
/**
 * Axios请求封装
 */
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ElMessage } from 'element-plus';
import { useUserStore } from '@/store/modules/user';
import { ApiResponse } from '@/types/api';

// 创建axios实例
const service: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  }
});

// 请求拦截器
service.interceptors.request.use(
  (config: AxiosRequestConfig) => {
    // 获取用户存储
    const userStore = useUserStore();
    
    // 如果有token，添加到请求头
    if (userStore.token) {
      config.headers = config.headers || {};
      config.headers.Authorization = `Bearer ${userStore.token}`;
    }
    
    return config;
  },
  (error) => {
    console.error('请求错误:', error);
    return Promise.reject(error);
  }
);

// 响应拦截器
service.interceptors.response.use(
  <T = any>(response: AxiosResponse<ApiResponse<T>>) => {
    const res = response.data;
    
    // 如果状态码不是200，视为错误
    if (res.code !== 200) {
      // 错误消息提示
      ElMessage.error(res.message || '请求失败');
      
      // 如果是401，说明token过期，需要重新登录
      if (res.code === 401) {
        const userStore = useUserStore();
        userStore.logout();
        window.location.href = '/login';
      }
      
      return Promise.reject(new Error(res.message || '请求失败'));
    }
    
    return res;
  },
  (error) => {
    console.error('响应错误:', error);
    
    // 错误消息处理
    let errorMessage = '网络错误，请稍后重试';
    
    if (error.response) {
      switch (error.response.status) {
        case 400:
          errorMessage = '请求参数错误';
          break;
        case 401:
          errorMessage = '未授权，请重新登录';
          const userStore = useUserStore();
          userStore.logout();
          window.location.href = '/login';
          break;
        case 403:
          errorMessage = '拒绝访问';
          break;
        case 404:
          errorMessage = '请求的资源不存在';
          break;
        case 500:
          errorMessage = '服务器内部错误';
          break;
        default:
          errorMessage = error.response.data?.message || errorMessage;
      }
    } else if (error.request) {
      errorMessage = '网络连接失败，请检查您的网络';
    }
    
    ElMessage.error(errorMessage);
    return Promise.reject(error);
  }
);

// 导出请求方法
export default service;

// 类型定义
export const request = <T = any>(config: AxiosRequestConfig): Promise<ApiResponse<T>> => {
  return service(config);
};

export const get = <T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> => {
  return service.get(url, config);
};

export const post = <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> => {
  return service.post(url, data, config);
};

export const put = <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> => {
  return service.put(url, data, config);
};

export const del = <T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> => {
  return service.delete(url, config);
};
```

##### 7.2.3.4 组件设计规范

1. **组件命名规范**
   - 组件名使用 PascalCase 格式
   - 文件命名与组件名一致，如 `UserProfile.vue`
   - 对于业务组件，可在前面加上业务域前缀，如 `RecipeCard.vue`

2. **组件结构**
   ```vue
   <template>
     <!-- 组件模板 -->
   </template>
   
   <script setup lang="ts">
   // 组件逻辑
   </script>
   
   <style scoped lang="scss">
   /* 组件样式 */
   </style>
   ```

3. **组件接口定义**
   - 使用 TypeScript 定义 Props 和 Emits
   - 为 Props 添加默认值和验证
   - 使用 defineProps 和 defineEmits 进行类型定义

4. **代码规范**
   - 遵循 Vue 3 的 Composition API 风格
   - 使用 TypeScript 进行类型检查
   - 避免使用 any 类型
   - 合理使用 ref、reactive、computed 等响应式 API

### 7.3 核心功能模块设计

#### 7.3.1 用户认证模块

```typescript
/**
 * 登录页面逻辑
 */
import { ref, reactive } from 'vue';
import { useRouter } from 'vue-router';
import { useUserStore } from '@/store/modules/user';
import { getCaptcha } from '@/api/auth';
import { validateUsername, validatePassword } from '@/utils/validate';

const router = useRouter();
const userStore = useUserStore();

// 登录表单
const form = reactive({
  username: '',
  password: '',
  captcha: '',
  captchaKey: ''
});

// 验证码图片
const captchaImage = ref('');

// 加载状态
const loading = ref(false);

// 表单规则
const rules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { validator: validateUsername, trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { validator: validatePassword, trigger: 'blur' }
  ],
  captcha: [
    { required: true, message: '请输入验证码', trigger: 'blur' }
  ]
};

// 刷新验证码
const refreshCaptcha = async () => {
  try {
    const response = await getCaptcha();
    form.captchaKey = response.headers['captcha-key'];
    captchaImage.value = URL.createObjectURL(new Blob([response.data]));
  } catch (error) {
    console.error('获取验证码失败:', error);
  }
};

// 提交登录
const handleLogin = async () => {
  try {
    loading.value = true;
    await userStore.login(form.username, form.password, form.captcha, form.captchaKey);
    await userStore.getUserInfo();
    router.push('/');
  } catch (error) {
    console.error('登录失败:', error);
    refreshCaptcha(); // 登录失败后刷新验证码
  } finally {
    loading.value = false;
  }
};

// 初始化
refreshCaptcha();
```

#### 7.3.2 食谱浏览模块

```typescript
/**
 * 食谱列表页面逻辑
 */
import { ref, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { ElMessage } from 'element-plus';
import { getRecipeList, searchRecipes } from '@/api/recipe';
import { Recipe } from '@/types/recipe';

const route = useRoute();
const router = useRouter();

// 食谱列表
const recipeList = ref<Recipe[]>([]);

// 分页信息
const pagination = ref({
  currentPage: 1,
  pageSize: 10,
  total: 0
});

// 搜索关键词
const keyword = ref('');

// 筛选条件
const filters = ref({
  category: '',
  mealType: ''
});

// 加载状态
const loading = ref(false);

// 获取食谱列表
const loadRecipes = async () => {
  try {
    loading.value = true;
    let result;
    
    if (keyword.value) {
      // 搜索食谱
      result = await searchRecipes({
        keyword: keyword.value,
        pageNum: pagination.value.currentPage,
        pageSize: pagination.value.pageSize
      });
    } else {
      // 筛选食谱
      result = await getRecipeList({
        category: filters.value.category,
        mealType: filters.value.mealType,
        pageNum: pagination.value.currentPage,
        pageSize: pagination.value.pageSize
      });
    }
    
    recipeList.value = result.data.list || [];
    pagination.value.total = result.data.total || 0;
  } catch (error) {
    console.error('获取食谱列表失败:', error);
    ElMessage.error('获取食谱列表失败');
  } finally {
    loading.value = false;
  }
};

// 搜索
const handleSearch = () => {
  pagination.value.currentPage = 1;
  loadRecipes();
};

// 重置筛选
const handleReset = () => {
  keyword.value = '';
  filters.value = {
    category: '',
    mealType: ''
  };
  pagination.value.currentPage = 1;
  loadRecipes();
};

// 分页变更
const handlePageChange = (current: number) => {
  pagination.value.currentPage = current;
  loadRecipes();
};

// 查看详情
const viewDetail = (id: number) => {
  router.push(`/recipe/detail/${id}`);
};

// 初始化
onMounted(() => {
  loadRecipes();
});
```

#### 7.3.3 膳食计划模块

```typescript
/**
 * 膳食计划列表页面逻辑
 */
import { ref, reactive, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage } from 'element-plus';
import { getMealPlanList, deleteMealPlan, updateMealPlanStatus } from '@/api/meal-plan';
import { MealPlan } from '@/types/meal-plan';

const router = useRouter();

// 日期范围
const dateRange = ref<[Date, Date]>([new Date(), new Date()]);

// 膳食计划列表
const mealPlanList = ref<MealPlan[]>([]);

// 加载状态
const loading = ref(false);

// 计算每日分组的膳食计划
const groupedMealPlans = computed(() => {
  const groups: Record<string, MealPlan[]> = {};
  
  mealPlanList.value.forEach(plan => {
    const date = plan.planDate;
    if (!groups[date]) {
      groups[date] = [];
    }
    groups[date].push(plan);
  });
  
  return groups;
});

// 获取膳食计划列表
const loadMealPlans = async () => {
  try {
    loading.value = true;
    const result = await getMealPlanList({
      startDate: dateRange.value[0],
      endDate: dateRange.value[1]
    });
    
    mealPlanList.value = result.data || [];
  } catch (error) {
    console.error('获取膳食计划失败:', error);
    ElMessage.error('获取膳食计划失败');
  } finally {
    loading.value = false;
  }
};

// 删除计划
const handleDelete = async (id: number) => {
  try {
    await deleteMealPlan(id);
    ElMessage.success('删除成功');
    loadMealPlans();
  } catch (error) {
    console.error('删除失败:', error);
    ElMessage.error('删除失败');
  }
};

// 更新完成状态
const updateStatus = async (id: number, completed: boolean) => {
  try {
    await updateMealPlanStatus(id, { completed });
    ElMessage.success('更新成功');
    loadMealPlans();
  } catch (error) {
    console.error('更新状态失败:', error);
    ElMessage.error('更新状态失败');
  }
};

// 添加计划
const addPlan = () => {
  router.push('/meal-plan/add');
};

// 日期范围变更
const handleDateRangeChange = () => {
  loadMealPlans();
};

// 初始化
onMounted(() => {
  loadMealPlans();
});
```

#### 7.3.4 营养分析模块

```typescript
/**
 * 营养分析页面逻辑
 */
import { ref, onMounted } from 'vue';
import { ElMessage } from 'element-plus';
import { getNutritionPlan, calculateBMI } from '@/api/nutrition';
import { getMealPlanStatistics } from '@/api/meal-plan';
import * as echarts from 'echarts';
import type { EChartsOption } from 'echarts';

// 营养计划数据
const nutritionPlan = ref<any>(null);

// BMI数据
const bmiData = ref({
  height: '',
  weight: '',
  bmi: 0,
  category: ''
});

// 统计图表实例
const chartInstance = ref<echarts.ECharts | null>(null);

// 日期范围
const dateRange = ref<[Date, Date]>([
  new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
  new Date()
]);

// 加载状态
const loading = ref(false);

// 获取营养计划
const loadNutritionPlan = async () => {
  try {
    const result = await getNutritionPlan();
    nutritionPlan.value = result.data;
  } catch (error) {
    console.error('获取营养计划失败:', error);
  }
};

// 计算BMI
const calculateUserBMI = async () => {
  try {
    const result = await calculateBMI({
      height: parseFloat(bmiData.value.height),
      weight: parseFloat(bmiData.value.weight)
    });
    
    const bmi = result.data;
    bmiData.value.bmi = bmi;
    
    // 计算BMI分类
    if (bmi < 18.5) {
      bmiData.value.category = '偏瘦';
    } else if (bmi < 24) {
      bmiData.value.category = '正常';
    } else if (bmi < 28) {
      bmiData.value.category = '超重';
    } else {
      bmiData.value.category = '肥胖';
    }
  } catch (error) {
    console.error('计算BMI失败:', error);
    ElMessage.error('计算BMI失败');
  }
};

// 获取营养统计数据
const loadStatistics = async () => {
  try {
    const result = await getMealPlanStatistics({
      startDate: dateRange.value[0],
      endDate: dateRange.value[1]
    });
    
    const statistics = result.data;
    initChart(statistics);
  } catch (error) {
    console.error('获取统计数据失败:', error);
  }
};

// 初始化图表
const initChart = (data: any) => {
  if (!chartInstance.value) {
    chartInstance.value = echarts.init(document.getElementById('nutrition-chart')!);
  }
  
  const option: EChartsOption = {
    title: {
      text: '营养摄入趋势'
    },
    tooltip: {
      trigger: 'axis'
    },
    legend: {
      data: ['卡路里', '蛋白质', '碳水化合物', '脂肪']
    },
    xAxis: {
      type: 'category',
      data: data.dates
    },
    yAxis: {
      type: 'value'
    },
    series: [
      {
        name: '卡路里',
        type: 'line',
        data: data.calories
      },
      {
        name: '蛋白质',
        type: 'line',
        data: data.protein
      },
      {
        name: '碳水化合物',
        type: 'line',
        data: data.carbs
      },
      {
        name: '脂肪',
        type: 'line',
        data: data.fat
      }
    ]
  };
  
  chartInstance.value.setOption(option);
};

// 日期范围变更
const handleDateRangeChange = () => {
  loadStatistics();
};

// 初始化
onMounted(() => {
  loadNutritionPlan();
  loadStatistics();
  
  // 监听窗口大小变化，调整图表大小
  window.addEventListener('resize', () => {
    chartInstance.value?.resize();
  });
});
```

### 7.4 前端安全设计

#### 7.4.1 防止XSS攻击

```typescript
/**
 * XSS防护工具
 */
export const xssUtils = {
  // 转义HTML特殊字符
  escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  },
  
  // 清理用户输入
  sanitizeInput(input: string): string {
    // 移除可能的脚本标签
    return input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  },
  
  // 安全设置内容
  setInnerHTML(element: HTMLElement, html: string): void {
    // 使用DOMPurify库进行HTML清理
    if (typeof DOMPurify !== 'undefined') {
      element.innerHTML = DOMPurify.sanitize(html);
    } else {
      element.textContent = html; // 降级处理
    }
  }
};
```

#### 7.4.2 CSRF防护

```typescript
/**
 * CSRF防护工具
 */
import axios from '@/utils/request';

// 获取CSRF Token
export const getCsrfToken = (): string | null => {
  return document.cookie.split('; ').find(row => row.startsWith('XSRF-TOKEN='))?.split('=')[1] || null;
};

// 设置CSRF Token到请求头
export const setupCsrfProtection = () => {
  // 从Cookie获取CSRF Token并设置到请求头
  axios.interceptors.request.use(config => {
    const token = getCsrfToken();
    if (token) {
      config.headers['X-XSRF-TOKEN'] = decodeURIComponent(token);
    }
    return config;
  });
};
```

#### 7.4.3 密码安全处理

```typescript
/**
 * 密码工具
 */
export const passwordUtils = {
  // 密码强度检查
  checkPasswordStrength(password: string): number {
    let strength = 0;
    
    // 长度检查
    if (password.length >= 8) strength += 1;
    if (password.length >= 12) strength += 1;
    
    // 包含数字
    if (/\d/.test(password)) strength += 1;
    
    // 包含小写字母
    if (/[a-z]/.test(password)) strength += 1;
    
    // 包含大写字母
    if (/[A-Z]/.test(password)) strength += 1;
    
    // 包含特殊字符
    if (/[^A-Za-z0-9]/.test(password)) strength += 1;
    
    return Math.min(strength, 5); // 最高5分
  },
  
  // 获取密码强度描述
  getPasswordStrengthText(strength: number): string {
    const texts = ['弱', '一般', '中等', '良好', '强', '非常强'];
    return texts[strength] || '未知';
  },
  
  // 生成随机密码
  generateRandomPassword(length: number = 12): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
    let password = '';
    
    for (let i = 0; i < length; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    return password;
  }
};
```

## 8. 部署与集成方案

### 8.1 部署架构

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│   Nginx         │      │   应用服务器    │      │   数据库服务器  │
│   反向代理       │──────▶  Spring Boot    │──────▶  MySQL         │
│   静态资源服务    │      │   应用集群      │      │   Redis         │
└─────────────────┘      └─────────────────┘      └─────────────────┘
```

### 8.2 环境要求

| 组件 | 版本 | 说明 |
| :--- | :--- | :--- |
| JDK | 17+ | Java开发环境 |
| MySQL | 8.0+ | 主数据库 |
| Redis | 7.0+ | 缓存和会话存储 |
| Nginx | 1.20+ | 反向代理服务器 |
| Docker | 20.10+ | 容器化部署 |
| Docker Compose | 2.0+ | 多容器编排 |

### 8.3 构建与打包

#### 8.3.1 后端构建

```bash
# 克隆代码
https://github.com/your-org/health-system.git
cd health-system

# 构建后端
cd system
mvn clean package -DskipTests

# 构建Docker镜像
docker build -t health-system:latest .
```

Dockerfile 示例：
```dockerfile
FROM openjdk:17-jdk-alpine
WORKDIR /app
COPY target/health-system.jar /app/app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

#### 8.3.2 前端构建

```bash
# 进入前端目录
cd ../system/vue

# 安装依赖
npm install

# 构建前端
npm run build

# 构建Docker镜像
docker build -t health-system-frontend:latest .
```

前端 Dockerfile 示例：
```dockerfile
FROM nginx:alpine
COPY dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 8.4 Docker Compose 部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: health-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: health_system
      MYSQL_USER: health_user
      MYSQL_PASSWORD: userpassword
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "3306:3306"
    networks:
      - health-network

  # 使用本地内存缓存，无需Redis服务

  # 后端应用
  backend:
    image: health-system:latest
    container_name: health-backend
    restart: always
    depends_on:
      - mysql
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/health_system?useSSL=false&serverTimezone=UTC
      - SPRING_DATASOURCE_USERNAME=health_user
      - SPRING_DATASOURCE_PASSWORD=userpassword
      - JWT_SECRET=your_jwt_secret_key
    ports:
      - "8080:8080"
    networks:
      - health-network

  # 前端应用
  frontend:
    image: health-system-frontend:latest
    container_name: health-frontend
    restart: always
    ports:
      - "80:80"
    networks:
      - health-network

volumes:
  mysql-data:

networks:
  health-network:
    driver: bridge
```

### 8.5 Nginx 配置

```nginx
# nginx.conf
server {
    listen 80;
    server_name health-system.example.com;

    # 前端静态资源
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    # API接口代理
    location /api {
        proxy_pass http://backend:8080/api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 静态资源缓存
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg)$ {
        root /usr/share/nginx/html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000";
    }

    # 错误页面
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}
```

### 8.6 CI/CD 配置

#### 8.6.1 GitHub Actions 配置

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      # 后端构建和测试
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      
      - name: Build backend with Maven
        run: cd system && mvn -B package --file pom.xml
      
      # 前端构建和测试
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'npm'
          cache-dependency-path: system/vue/package-lock.json
      
      - name: Install dependencies
        run: cd system/vue && npm ci
      
      - name: Build frontend
        run: cd system/vue && npm run build
  
  docker-build-and-push:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      # 登录到Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # 构建并推送后端镜像
      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./system
          push: true
          tags: yourusername/health-system:latest,yourusername/health-system:${{ github.sha }}
      
      # 构建并推送前端镜像
      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./system/vue
          push: true
          tags: yourusername/health-system-frontend:latest,yourusername/health-system-frontend:${{ github.sha }}
```

### 8.7 数据迁移与初始化

#### 8.7.1 数据库初始化脚本

```sql
-- init.sql
-- 创建数据库（如果不存在）
CREATE DATABASE IF NOT EXISTS health_system DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

USE health_system;

-- 创建用户表
CREATE TABLE IF NOT EXISTS user (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(100) NOT NULL,
    name VARCHAR(50) NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(100),
    gender VARCHAR(10),
    height DOUBLE,
    weight DOUBLE,
    age INT,
    activity_level VARCHAR(20),
    goal VARCHAR(50),
    role VARCHAR(20) DEFAULT 'user',
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    is_deleted TINYINT DEFAULT 0
);

-- 创建管理员账户
INSERT INTO user (username, password, name, role, status) 
VALUES ('admin', '$2a$10$e7XJQxH5MhU5VxT7m7qXvewI8t6eA3nQ1d9V7v8Z9y5x9r8W5q7Ea', '系统管理员', 'admin', 1)
ON DUPLICATE KEY UPDATE name = name;

-- 创建其他表...
```

### 8.8 监控与日志

#### 8.8.1 应用日志配置

```yaml
# application.yml - 日志配置
logging:
  level:
    root: INFO
    com.health.system: DEBUG
  file:
    name: /logs/health-system.log
  pattern:
    console: '%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n'
    file: '%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n'
```

#### 8.8.2 Prometheus 监控配置

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'health-system'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['health-backend:8080']
```

### 8.9 安全加固措施

1. **环境变量管理**
   - 敏感信息如数据库密码、JWT密钥等通过环境变量配置，不硬编码
   - 使用密钥管理服务存储敏感配置

2. **定期备份**
   ```bash
   # 数据库备份脚本
   #!/bin/bash
   DATE=$(date +%Y%m%d_%H%M%S)
   mysqldump -u health_user -puserpassword health_system > /backup/health_system_$DATE.sql
   gzip /backup/health_system_$DATE.sql
   ```

3. **定期更新**
   - 定期更新系统依赖和组件版本
   - 配置安全扫描，及时发现和修复漏洞

4. **防火墙配置**
   - 仅开放必要的端口（80, 443, 3306等）
   - 限制数据库只能从应用服务器访问

### 8.10 系统集成测试

#### 8.10.1 测试环境配置

```yaml
# docker-compose.test.yml
version: '3.8'

services:
  # 测试数据库
  mysql-test:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: test_root
      MYSQL_DATABASE: health_system_test
      MYSQL_USER: test_user
      MYSQL_PASSWORD: test_password
    ports:
      - "3307:3306"
    networks:
      - test-network

  # 测试后端
  backend-test:
    build: ./system
    environment:
      - SPRING_PROFILES_ACTIVE=test
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql-test:3306/health_system_test
      - SPRING_DATASOURCE_USERNAME=test_user
      - SPRING_DATASOURCE_PASSWORD=test_password
    depends_on:
      - mysql-test
    networks:
      - test-network

networks:
  test-network:
    driver: bridge
```

#### 8.10.2 API测试示例（使用JUnit）

```java
/**
 * API测试类
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class RecipeApiTest {
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    private String token;
    
    @BeforeEach
    void setUp() {
        // 创建测试用户并获取token
        User testUser = new User();
        testUser.setUsername("testuser");
        testUser.setPassword(passwordEncoder.encode("password"));
        testUser.setRole("user");
        userRepository.save(testUser);
        
        // 登录获取token
        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("testuser");
        loginRequest.setPassword("password");
        
        ResponseEntity<ApiResponse<LoginResponse>> response = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/auth/login", 
            loginRequest, 
            new ParameterizedTypeReference<ApiResponse<LoginResponse>>() {}
        );
        
        token = "Bearer " + response.getBody().getData().getAccessToken();
    }
    
    @Test
    void testGetRecipeList() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", token);
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<ApiResponse<PageInfo<Recipe>>> response = restTemplate.exchange(
            "http://localhost:" + port + "/api/recipe/list",
            HttpMethod.GET,
            entity,
            new ParameterizedTypeReference<ApiResponse<PageInfo<Recipe>>>() {}
        );
        
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody().getData());
    }
}
```

### 8.11 灰度发布方案

1. **蓝绿部署**
   - 准备两套环境：蓝环境（当前运行版本）和绿环境（新版本）
   - 新版本部署到绿环境并验证
   - 通过Nginx切换流量到绿环境

2. **金丝雀发布**
   - 将少量流量（如5%）引导至新版本
   - 监控系统性能和错误率
   - 逐步增加流量，直到完全切换

```nginx
# 灰度发布配置示例
upstream backend_v1 {
    server backend-v1:8080;
}

upstream backend_v2 {
    server backend-v2:8080;
}

server {
    listen 80;
    
    location /api {
        # 灰度规则：部分用户访问新版本
        if ($http_cookie ~* "version=v2") {
            proxy_pass http://backend_v2;
        } else {
            # 默认使用旧版本
            proxy_pass http://backend_v1;
        }
    }
}
```

### 8.12 常见问题排查指南

1. **数据库连接失败**
   - 检查数据库地址、用户名和密码是否正确
   - 确认数据库服务是否运行
   - 验证网络连接和防火墙设置

2. **API响应超时**
   - 检查数据库查询性能
   - 验证本地内存缓存是否正常
   - 查看应用日志中的慢查询记录

3. **前端页面加载异常**
   - 检查Nginx配置是否正确
   - 验证静态资源路径
   - 查看浏览器控制台错误信息

4. **Token认证失败**
   - 检查JWT密钥配置
   - 验证Token是否过期
   - 确认请求头中的Token格式正确

通过以上部署与集成方案，可以实现健康饮食系统的稳定部署和运行。根据实际需求，可以进一步优化配置和扩展系统功能。

# 9. 系统测试与质量保障方案

## 9.1 测试策略

### 9.1.1 测试目标
- 验证系统功能是否符合需求规格
- 确保系统性能满足预期
- 保障数据安全性和完整性
- 验证系统在不同环境下的稳定性
- 确保用户体验符合设计要求

### 9.1.2 测试范围
- 功能测试：覆盖所有业务功能点
- 性能测试：API响应时间、并发处理能力
- 安全测试：用户认证、权限控制、数据加密
- 兼容性测试：不同浏览器、设备的兼容性
- 可用性测试：用户界面易用性、错误提示友好性

### 9.1.3 测试方法
- 黑盒测试：基于需求规格进行功能验证
- 白盒测试：代码逻辑和内部结构测试
- 自动化测试：关键流程自动化验证
- 探索性测试：发现潜在问题和改进点
- 回归测试：确保修改不引入新问题

## 9.2 单元测试

### 9.2.1 单元测试框架
```java
// 使用JUnit 5和Mockito进行单元测试
@ExtendWith(MockitoExtension.class)
public class NutritionAnalysisServiceTest {
    
    @Mock
    private UserService userService;
    
    @Mock
    private RecipeService recipeService;
    
    @InjectMocks
    private NutritionAnalysisServiceImpl nutritionAnalysisService;
    
    @Test
    public void testCalculateBMI() {
        // 准备测试数据
        double height = 170.0; // cm
        double weight = 65.0;  // kg
        double expectedBMI = 22.49; // 65 / (1.7 * 1.7)
        
        // 执行测试
        double actualBMI = nutritionAnalysisService.calculateBMI(height, weight);
        
        // 验证结果
        assertEquals(expectedBMI, actualBMI, 0.01);
    }
    
    @Test
    public void testCalculateBMR_Male() {
        // 准备测试数据
        String gender = "男";
        double weight = 65.0; // kg
        double height = 170.0; // cm
        int age = 30;
        double expectedBMR = 66 + (13.7 * 65) + (5 * 170) - (6.8 * 30);
        
        // 执行测试
        double actualBMR = nutritionAnalysisService.calculateBMR(gender, weight, height, age);
        
        // 验证结果
        assertEquals(expectedBMR, actualBMR, 0.01);
    }
    
    @Test
    public void testCalculateBMR_Female() {
        // 准备测试数据
        String gender = "女";
        double weight = 55.0; // kg
        double height = 160.0; // cm
        int age = 25;
        double expectedBMR = 655 + (9.6 * 55) + (1.8 * 160) - (4.7 * 25);
        
        // 执行测试
        double actualBMR = nutritionAnalysisService.calculateBMR(gender, weight, height, age);
        
        // 验证结果
        assertEquals(expectedBMR, actualBMR, 0.01);
    }
    
    @Test
    public void testRecommendRecipes() {
        // 准备测试数据
        Integer userId = 1;
        String mealType = "早餐";
        Integer count = 3;
        
        // 模拟用户营养计划
        NutritionPlan nutritionPlan = new NutritionPlan();
        nutritionPlan.setRecommendedCalories(2000.0);
        
        // 设置模拟行为
        when(nutritionAnalysisService.getNutritionPlan(userId)).thenReturn(nutritionPlan);
        
        // 执行测试
        List<Recipe> result = nutritionAnalysisService.recommendRecipes(userId, mealType, count);
        
        // 验证结果
        assertNotNull(result);
        assertEquals(3, result.size());
    }
}
```

### 9.2.2 服务层测试
```java
@ExtendWith(MockitoExtension.class)
public class UserServiceImplTest {
    
    @Mock
    private UserMapper userMapper;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @Mock
    private MultiLevelCacheManager cacheManager;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    public void testAdd() {
        // 准备测试数据
        User user = new User();
        user.setUsername("testuser");
        user.setPassword("password123");
        user.setEmail("test@example.com");
        
        // 设置模拟行为
        when(passwordEncoder.encode("password123")).thenReturn("encodedPassword");
        when(userMapper.insert(user)).thenReturn(1);
        
        // 执行测试
        boolean result = userService.add(user);
        
        // 验证结果
        assertTrue(result);
        assertEquals("encodedPassword", user.getPassword());
        verify(userMapper, times(1)).insert(user);
    }
    
    @Test
    public void testDeleteById() {
        // 准备测试数据
        Integer userId = 1;
        
        // 设置模拟行为
        when(userMapper.deleteById(userId)).thenReturn(1);
        
        // 执行测试
        boolean result = userService.deleteById(userId);
        
        // 验证结果
        assertTrue(result);
        verify(userMapper, times(1)).deleteById(userId);
        verify(cacheManager, times(1)).delete("user:info:" + userId);
    }
    
    @Test
    public void testSelectByUsername() {
        // 准备测试数据
        String username = "testuser";
        User expectedUser = new User();
        expectedUser.setId(1);
        expectedUser.setUsername(username);
        
        // 设置模拟行为
        when(cacheManager.get("user:info:testuser", User.class)).thenReturn(null);
        when(userMapper.selectByUsername(username)).thenReturn(expectedUser);
        
        // 执行测试
        User actualUser = userService.selectByUsername(username);
        
        // 验证结果
        assertNotNull(actualUser);
        assertEquals(username, actualUser.getUsername());
        verify(cacheManager, times(1)).set("user:info:testuser", expectedUser, 30, TimeUnit.MINUTES);
    }
}
```

### 9.2.3 控制器测试
```java
@WebMvcTest(UserController.class)
public class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void testGetUserInfo() throws Exception {
        // 准备测试数据
        User user = new User();
        user.setId(1);
        user.setUsername("testuser");
        user.setEmail("test@example.com");
        
        // 设置模拟行为
        when(userService.selectById(1)).thenReturn(user);
        
        // 执行测试
        mockMvc.perform(get("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.username").value("testuser"));
    }
    
    @Test
    public void testUpdateUser() throws Exception {
        // 准备测试数据
        UserUpdateRequest request = new UserUpdateRequest();
        request.setEmail("newemail@example.com");
        request.setPhone("13800138000");
        
        // 设置模拟行为
        when(userService.updateById(1, any(User.class))).thenReturn(true);
        
        // 执行测试
        mockMvc.perform(put("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.success").value(true));
    }
    
    @Test
    public void testUpdateUser_InvalidData() throws Exception {
        // 准备无效测试数据
        UserUpdateRequest request = new UserUpdateRequest();
        request.setEmail("invalid-email"); // 无效邮箱格式
        
        // 执行测试
        mockMvc.perform(put("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.success").value(false))
                .andExpect(jsonPath("$.message").exists());
    }
}
```

## 9.3 集成测试

### 9.3.1 数据库集成测试
```java
@SpringBootTest
@Transactional
public class UserMapperTest {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Test
    public void testInsertAndSelect() {
        // 创建测试用户
        User user = new User();
        user.setUsername("testuser");
        user.setPassword(passwordEncoder.encode("password123"));
        user.setEmail("test@example.com");
        user.setPhone("13800138000");
        user.setCreateTime(new Date());
        
        // 插入用户
        int insertResult = userMapper.insert(user);
        assertEquals(1, insertResult);
        assertNotNull(user.getId());
        
        // 查询用户
        User selectedUser = userMapper.selectById(user.getId());
        assertNotNull(selectedUser);
        assertEquals("testuser", selectedUser.getUsername());
        assertEquals("test@example.com", selectedUser.getEmail());
    }
    
    @Test
    public void testUpdate() {
        // 先插入测试数据
        User user = new User();
        user.setUsername("updatetest");
        user.setPassword(passwordEncoder.encode("password123"));
        user.setEmail("update@example.com");
        userMapper.insert(user);
        
        // 更新数据
        user.setEmail("updated@example.com");
        user.setPhone("13900139000");
        int updateResult = userMapper.updateById(user);
        
        // 验证更新
        assertEquals(1, updateResult);
        User updatedUser = userMapper.selectById(user.getId());
        assertEquals("updated@example.com", updatedUser.getEmail());
        assertEquals("13900139000", updatedUser.getPhone());
    }
    
    @Test
    public void testDelete() {
        // 先插入测试数据
        User user = new User();
        user.setUsername("deletetest");
        user.setPassword(passwordEncoder.encode("password123"));
        user.setEmail("delete@example.com");
        userMapper.insert(user);
        
        // 删除数据
        int deleteResult = userMapper.deleteById(user.getId());
        
        // 验证删除
        assertEquals(1, deleteResult);
        User deletedUser = userMapper.selectById(user.getId());
        assertNull(deletedUser);
    }
}
```

### 9.3.2 API集成测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class NutritionAnalysisApiTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    private String getRootUrl() {
        return "http://localhost:" + port + "/api";
    }
    
    @BeforeEach
    public void setup() {
        // 创建测试用户
        User user = new User();
        user.setUsername("apitestuser");
        user.setPassword(passwordEncoder.encode("password123"));
        user.setEmail("apitest@example.com");
        userMapper.insert(user);
    }
    
    @Test
    public void testCalculateBMI() {
        // 准备测试数据
        Map<String, Double> request = new HashMap<>();
        request.put("height", 170.0);
        request.put("weight", 65.0);
        
        // 执行API请求
        ResponseEntity<BmiResponse> response = restTemplate.postForEntity(
            getRootUrl() + "/nutrition/bmi", 
            request, 
            BmiResponse.class
        );
        
        // 验证响应
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals(22.49, response.getBody().getBmi(), 0.01);
        assertEquals("正常体重", response.getBody().getCategory());
    }
    
    @Test
    public void testGenerateMealPlan() {
        // 准备测试数据
        MealPlanRequest request = new MealPlanRequest();
        request.setUserId(1);
        request.setDays(7);
        request.setStartDate(new Date());
        
        // 执行API请求
        ResponseEntity<List<MealPlan>> response = restTemplate.postForEntity(
            getRootUrl() + "/meal-plans/generate", 
            request, 
            new ParameterizedTypeReference<List<MealPlan>>() {}
        );
        
        // 验证响应
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals(7, response.getBody().size());
    }
}
```

## 9.4 性能测试

### 9.4.1 JMeter测试计划

**用户登录测试脚本**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.4.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="用户登录测试计划" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="登录用户组" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">100</stringProp>
        <stringProp name="ThreadGroup.ramp_time">30</stringProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">60</stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="登录请求" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{"username":"user${__Random(1,1000)}","password":"password123"}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name"></stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">localhost</stringProp>
          <stringProp name="HTTPSampler.port">8080</stringProp>
          <stringProp name="HTTPSampler.protocol">http</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/api/auth/login</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="请求头设置" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

### 9.4.2 性能监控

#### 9.4.2.1 Spring Boot Actuator配置
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

#### 9.4.2.2 Prometheus配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'health_system'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
```

#### 9.4.2.3 关键性能指标
```java
// 自定义性能指标
@Component
public class CustomMetrics {
    private final MeterRegistry meterRegistry;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 注册食谱推荐耗时指标
        Timer.builder("nutrition.recipe.recommend.time")
            .description("Time taken to recommend recipes")
            .tags("service", "nutrition-analysis")
            .register(meterRegistry);
        
        // 注册营养计算指标
        Counter.builder("nutrition.calculation.count")
            .description("Number of nutrition calculations performed")
            .tag("type", "bmi")
            .register(meterRegistry);
        
        // 注册API错误率指标
        Counter.builder("api.errors.count")
            .description("Number of API errors")
            .tags("service", "nutrition-system")
            .register(meterRegistry);
    }
}
```

## 9.5 安全测试

### 9.5.1 认证与授权测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class SecurityTests {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserService userService;
    
    @BeforeEach
    public void setup() {
        // 创建测试用户
        User adminUser = new User();
        adminUser.setUsername("admin");
        adminUser.setPassword(passwordEncoder.encode("admin123"));
        adminUser.setRole("ADMIN");
        userService.add(adminUser);
        
        User normalUser = new User();
        normalUser.setUsername("user");
        normalUser.setPassword(passwordEncoder.encode("user123"));
        normalUser.setRole("USER");
        userService.add(normalUser);
    }
    
    @Test
    public void testUnauthorizedAccess() {
        // 未授权访问受保护资源
        ResponseEntity<String> response = restTemplate.getForEntity(
            "http://localhost:" + port + "/api/users", 
            String.class
        );
        
        assertEquals(HttpStatus.UNAUTHORIZED, response.getStatusCode());
    }
    
    @Test
    public void testAccessDenied() {
        // 普通用户尝试访问管理员功能
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + getJwtToken("user", "user123"));
        
        HttpEntity<String> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(
            "http://localhost:" + port + "/api/admin/users", 
            HttpMethod.GET, 
            entity, 
            String.class
        );
        
        assertEquals(HttpStatus.FORBIDDEN, response.getStatusCode());
    }
    
    @Test
    public void testSuccessfulAuthentication() {
        // 成功认证并访问资源
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + getJwtToken("admin", "admin123"));
        
        HttpEntity<String> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(
            "http://localhost:" + port + "/api/admin/users", 
            HttpMethod.GET, 
            entity, 
            String.class
        );
        
        assertEquals(HttpStatus.OK, response.getStatusCode());
    }
    
    private String getJwtToken(String username, String password) {
        // 登录获取JWT token
        Map<String, String> credentials = new HashMap<>();
        credentials.put("username", username);
        credentials.put("password", password);
        
        ResponseEntity<Map> response = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/auth/login", 
            credentials, 
            Map.class
        );
        
        return (String) response.getBody().get("token");
    }
}
```

### 9.5.2 数据安全测试

#### 9.5.2.1 SQL注入防护测试
```java
@SpringBootTest
public class SqlInjectionTests {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private RecipeService recipeService;
    
    @Test
    public void testUsernameSearch_SqlInjection() {
        // 尝试SQL注入攻击
        String maliciousInput = "admin' OR '1'='1";
        User user = userService.selectByUsername(maliciousInput);
        
        // 验证没有返回所有用户
        assertNull(user); // 应该返回null，因为不存在这样的用户名
    }
    
    @Test
    public void testRecipeSearch_SqlInjection() {
        // 尝试SQL注入攻击
        String maliciousInput = "%' ; DROP TABLE recipe; --";
        List<Recipe> recipes = recipeService.searchRecipes(maliciousInput);
        
        // 验证数据库操作安全
        assertNotNull(recipes); // 应该返回空列表或正常结果，而不是错误
        // 验证recipe表仍然存在
        assertTrue(recipeService.list().size() > 0);
    }
}
```

#### 9.5.2.2 XSS防护测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class XssTests {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    public void testCreateRecipeWithXss() {
        // 准备XSS攻击载荷
        Map<String, Object> recipeData = new HashMap<>();
        recipeData.put("name", "<script>alert('XSS')</script>测试食谱");
        recipeData.put("description", "测试描述<script>document.location='http://attacker.com'</script>");
        recipeData.put("category", "早餐");
        recipeData.put("calories", 300);
        
        // 发送请求
        ResponseEntity<Map> response = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/recipes", 
            recipeData, 
            Map.class
        );
        
        // 验证请求是否成功（取决于验证配置）
        // 如果启用了XSS过滤，应该返回错误或过滤后的内容
        if (response.getStatusCode() == HttpStatus.OK) {
            // 验证XSS内容是否被过滤
            Integer recipeId = (Integer) response.getBody().get("id");
            ResponseEntity<Map> getResponse = restTemplate.getForEntity(
                "http://localhost:" + port + "/api/recipes/" + recipeId, 
                Map.class
            );
            
            String name = (String) getResponse.getBody().get("name");
            assertFalse(name.contains("<script>"));
        }
    }
}
```

## 9.6 质量保障措施

### 9.6.1 代码质量检查

#### 9.6.1.1 SonarQube配置
```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.9.1.2184</version>
</plugin>
```

```properties
# sonar-project.properties
sonar.projectKey=health_system
sonar.projectName=健康营养系统
sonar.projectVersion=1.0

# 源代码位置
sonar.sources=src/main/java
sonar.java.binaries=target/classes

# 测试代码位置
sonar.tests=src/test/java
sonar.java.test.binaries=target/test-classes

# 编码设置
sonar.sourceEncoding=UTF-8

# 质量门禁设置
sonar.qualitygate.wait=true

# 排除的文件
sonar.exclusions=**/generated/**,**/model/**/Q*.java
```

#### 9.6.1.2 代码覆盖率要求
- 服务层代码覆盖率：≥ 85%
- 工具类代码覆盖率：≥ 90%
- 控制器代码覆盖率：≥ 75%
- 整体项目代码覆盖率：≥ 80%

### 9.6.2 代码审查流程

#### 9.6.2.1 代码审查清单
```markdown
# 代码审查清单

## 功能验证
- [ ] 代码是否实现了预期功能？
- [ ] 是否满足所有需求规格？
- [ ] 边界情况是否得到处理？

## 代码质量
- [ ] 代码是否遵循项目编码规范？
- [ ] 是否有重复代码需要重构？
- [ ] 方法和类的命名是否清晰？
- [ ] 注释是否充分且有意义？

## 性能考虑
- [ ] 是否有潜在的性能瓶颈？
- [ ] 数据库查询是否高效？
- [ ] 是否合理使用了缓存？

## 安全性
- [ ] 是否存在SQL注入风险？
- [ ] 是否存在XSS攻击风险？
- [ ] 敏感数据是否得到保护？
- [ ] 权限控制是否正确实现？

## 可测试性
- [ ] 代码是否可测试？
- [ ] 是否编写了单元测试？
- [ ] 测试覆盖率是否达标？

## 依赖管理
- [ ] 是否引入了不必要的依赖？
- [ ] 依赖版本是否兼容？
- [ ] 是否存在安全漏洞的依赖？
```

#### 9.6.2.2 审查工作流
1. 开发者提交代码并创建合并请求
2. 至少一名团队成员进行代码审查
3. 审查者根据代码审查清单检查代码
4. 发现问题时提出修改建议
5. 开发者修复问题并再次提交
6. 审查通过后合并代码

### 9.6.3 持续集成/持续部署

#### 9.6.3.1 Jenkins Pipeline
```groovy
// Jenkinsfile
pipeline {
    agent any
    
    tools {
        maven 'Maven 3.8.4'
        jdk 'JDK 11'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                sh 'mvn clean package -DskipTests'
            }
        }
        
        stage('Unit Tests') {
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                    jacoco(execPattern: '**/target/jacoco.exec')
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                sh 'mvn verify -DskipUnitTests'
            }
            post {
                always {
                    junit '**/target/failsafe-reports/*.xml'
                }
            }
        }
        
        stage('Code Quality') {
            steps {
                sh 'mvn sonar:sonar'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                sh 'docker build -t health-system:${BUILD_NUMBER} .'
            }
        }
        
        stage('Deploy to Test') {
            when {
                branch 'develop'
            }
            steps {
                sh 'docker-compose -f docker-compose.test.yml up -d'
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'master'
            }
            steps {
                sh 'docker-compose -f docker-compose.prod.yml up -d'
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo 'Build successful!'
        }
        failure {
            echo 'Build failed!'
            mail to: 'team@example.com', 
                 subject: "构建失败: ${env.JOB_NAME} #${env.BUILD_NUMBER}", 
                 body: "请查看构建日志: ${env.BUILD_URL}"
        }
    }
}
```

## 9.7 回归测试策略

### 9.7.1 自动化回归测试
```java
@SpringBootTest
@ActiveProfiles("test")
public class RegressionTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private RecipeService recipeService;
    
    @Autowired
    private NutritionAnalysisService nutritionAnalysisService;
    
    @Autowired
    private MealPlanService mealPlanService;
    
    @Test
    public void testUserManagementRegression() {
        // 测试用户创建
        User user = new User();
        user.setUsername("regression_test_user");
        user.setPassword("password123");
        user.setEmail("regression@example.com");
        assertTrue(userService.add(user));
        
        // 测试用户查询
        User foundUser = userService.selectByUsername("regression_test_user");
        assertNotNull(foundUser);
        assertEquals("regression@example.com", foundUser.getEmail());
        
        // 测试用户更新
        foundUser.setPhone("13800138000");
        assertTrue(userService.updateById(foundUser.getId(), foundUser));
        
        // 测试用户删除
        assertTrue(userService.deleteById(foundUser.getId()));
    }
    
    @Test
    public void testRecipeAndNutritionRegression() {
        // 测试食谱创建
        Recipe recipe = new Recipe();
        recipe.setName("回归测试食谱");
        recipe.setDescription("测试食谱描述");
        recipe.setCategory("早餐");
        recipe.setCalories(300);
        assertTrue(recipeService.add(recipe));
        
        // 测试营养分析
        NutritionAnalysis analysis = nutritionAnalysisService.analyzeRecipeNutrition(recipe.getId());
        assertNotNull(analysis);
        assertEquals(300, analysis.getCalories());
        
        // 测试食谱推荐
        List<Recipe> recommendations = nutritionAnalysisService.recommendRecipes(1, "早餐", 5);
        assertNotNull(recommendations);
        assertFalse(recommendations.isEmpty());
        
        // 测试膳食计划生成
        List<MealPlan> mealPlans = mealPlanService.generateMealPlan(1, new Date(), 3);
        assertNotNull(mealPlans);
        assertEquals(3, mealPlans.size());
    }
}
```

### 9.7.2 关键业务流程测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class EndToEndFlowTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    public void testUserRegistrationToMealPlanFlow() {
        // 1. 用户注册
        Map<String, String> registrationData = new HashMap<>();
        registrationData.put("username", "e2etestuser");
        registrationData.put("password", "password123");
        registrationData.put("email", "e2etest@example.com");
        
        ResponseEntity<Map> registerResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/auth/register", 
            registrationData, 
            Map.class
        );
        
        assertEquals(HttpStatus.OK, registerResponse.getStatusCode());
        assertTrue((Boolean) registerResponse.getBody().get("success"));
        
        // 2. 用户登录
        Map<String, String> loginData = new HashMap<>();
        loginData.put("username", "e2etestuser");
        loginData.put("password", "password123");
        
        ResponseEntity<Map> loginResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/auth/login", 
            loginData, 
            Map.class
        );
        
        assertEquals(HttpStatus.OK, loginResponse.getStatusCode());
        String token = (String) loginResponse.getBody().get("token");
        
        // 3. 设置用户健康信息
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + token);
        headers.set("Content-Type", "application/json");
        
        Map<String, Object> healthData = new HashMap<>();
        healthData.put("height", 170.0);
        healthData.put("weight", 65.0);
        healthData.put("age", 30);
        healthData.put("gender", "男");
        healthData.put("activityLevel", "中等");
        healthData.put("goal", "维持体重");
        
        HttpEntity<Map<String, Object>> healthEntity = new HttpEntity<>(healthData, headers);
        ResponseEntity<Map> healthResponse = restTemplate.exchange(
            "http://localhost:" + port + "/api/users/health", 
            HttpMethod.POST, 
            healthEntity, 
            Map.class
        );
        
        assertEquals(HttpStatus.OK, healthResponse.getStatusCode());
        
        // 4. 获取营养计划
        HttpEntity<String> planEntity = new HttpEntity<>(headers);
        ResponseEntity<Map> planResponse = restTemplate.exchange(
            "http://localhost:" + port + "/api/nutrition/plan", 
            HttpMethod.GET, 
            planEntity, 
            Map.class
        );
        
        assertEquals(HttpStatus.OK, planResponse.getStatusCode());
        assertNotNull(planResponse.getBody().get("recommendedCalories"));
        
        // 5. 生成膳食计划
        Map<String, Object> mealPlanData = new HashMap<>();
        mealPlanData.put("days", 7);
        mealPlanData.put("startDate", new Date());
        
        HttpEntity<Map<String, Object>> mealPlanEntity = new HttpEntity<>(mealPlanData, headers);
        ResponseEntity<List> mealPlanResponse = restTemplate.exchange(
            "http://localhost:" + port + "/api/meal-plans/generate", 
            HttpMethod.POST, 
            mealPlanEntity, 
            List.class
        );
        
        assertEquals(HttpStatus.OK, mealPlanResponse.getStatusCode());
        assertNotNull(mealPlanResponse.getBody());
        assertTrue(mealPlanResponse.getBody().size() > 0);
    }
}
```

## 9.8 测试环境管理

### 9.8.1 环境配置文件

#### 9.8.1.1 开发环境
```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/health_system_dev
    username: dev_user
    password: dev_password
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

server:
  port: 8080

logging:
  level:
    root: INFO
    com.health: DEBUG
```

#### 9.8.1.2 测试环境
```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/health_system_test
    username: test_user
    password: test_password
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: create-drop

server:
  port: 8081

logging:
  level:
    root: INFO
    com.health: DEBUG
```

#### 9.8.1.3 生产环境
```yaml
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://db:3306/health_system
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: validate

server:
  port: 8080
  compression:
    enabled: true

logging:
  level:
    root: WARN
    com.health: INFO
```

### 9.8.2 测试数据管理

#### 9.8.2.1 测试数据生成器
```java
@Component
public class TestDataGenerator {
    
    private final UserMapper userMapper;
    private final RecipeMapper recipeMapper;
    private final PasswordEncoder passwordEncoder;
    
    public TestDataGenerator(UserMapper userMapper, RecipeMapper recipeMapper, PasswordEncoder passwordEncoder) {
        this.userMapper = userMapper;
        this.recipeMapper = recipeMapper;
        this.passwordEncoder = passwordEncoder;
    }
    
    @PostConstruct
    public void generateTestData() {
        // 生成测试用户
        generateTestUsers();
        
        // 生成测试食谱
        generateTestRecipes();
    }
    
    private void generateTestUsers() {
        // 创建管理员用户
        User admin = new User();
        admin.setUsername("admin");
        admin.setPassword(passwordEncoder.encode("admin123"));
        admin.setEmail("admin@example.com");
        admin.setRole("ADMIN");
        admin.setCreateTime(new Date());
        userMapper.insert(admin);
        
        // 创建普通用户
        User user = new User();
        user.setUsername("user1");
        user.setPassword(passwordEncoder.encode("user123"));
        user.setEmail("user1@example.com");
        user.setRole("USER");
        user.setCreateTime(new Date());
        userMapper.insert(user);
        
        // 创建更多测试用户
        for (int i = 2; i <= 10; i++) {
            User testUser = new User();
            testUser.setUsername("user" + i);
            testUser.setPassword(passwordEncoder.encode("password123"));
            testUser.setEmail("user" + i + "@example.com");
            testUser.setRole("USER");
            testUser.setCreateTime(new Date());
            userMapper.insert(testUser);
        }
    }
    
    private void generateTestRecipes() {
        // 早餐食谱
        Recipe breakfast1 = new Recipe();
        breakfast1.setName("全麦面包配鸡蛋");
        breakfast1.setDescription("营养丰富的早餐选择");
        breakfast1.setCategory("早餐");
        breakfast1.setCalories(350);
        breakfast1.setDifficulty("简单");
        breakfast1.setCookingTime(10);
        recipeMapper.insert(breakfast1);
        
        // 午餐食谱
        Recipe lunch1 = new Recipe();
        lunch1.setName("鸡胸肉沙拉");
        lunch1.setDescription("健康低卡路里午餐");
        lunch1.setCategory("午餐");
        lunch1.setCalories(450);
        lunch1.setDifficulty("中等");
        lunch1.setCookingTime(20);
        recipeMapper.insert(lunch1);
        
        // 晚餐食谱
        Recipe dinner1 = new Recipe();
        dinner1.setName("清蒸鱼配蔬菜");
        dinner1.setDescription("高蛋白低脂肪晚餐");
        dinner1.setCategory("晚餐");
        dinner1.setCalories(400);
        dinner1.setDifficulty("中等");
        dinner1.setCookingTime(25);
        recipeMapper.insert(dinner1);
    }
}
```

## 9.9 问题追踪与修复流程

### 9.9.1 缺陷管理流程
1. **发现问题**：通过测试、用户反馈或代码审查发现问题
2. **记录问题**：在JIRA中创建问题单，包含详细描述、复现步骤和预期结果
3. **分类与优先级**：根据影响范围和严重程度分类
4. **分配修复**：分配给相关开发人员
5. **修复实现**：开发人员修复问题并提交代码
6. **代码审查**：修复代码经过审查
7. **验证测试**：测试人员验证修复是否有效
8. **关闭问题**：确认修复后关闭问题单

### 9.9.2 问题优先级定义
- **P0（紧急）**：系统完全不可用或数据丢失，需要立即修复
- **P1（高）**：主要功能不可用，但有临时解决方案
- **P2（中）**：次要功能问题，不影响核心使用
- **P3（低）**：小问题和改进建议

### 9.9.3 常见问题修复策略
- **性能问题**：使用性能分析工具定位瓶颈，优化数据库查询，添加缓存
- **安全漏洞**：及时更新依赖，实施安全补丁，加强输入验证
- **数据一致性问题**：使用事务确保数据一致性，添加数据验证
- **UI显示问题**：针对不同浏览器进行兼容性测试，修复CSS和JavaScript问题
- **系统稳定性问题**：添加错误处理和重试机制，监控系统状态